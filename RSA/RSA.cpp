#define OPENSSL_API_COMPAT 0x10100000L
#include <openssl/bn.h>
/*
Схема такая: 
    Нужны 2 простых числа p и q, они тайные и должны быть уничтожены после генерации ключа
    Публичный (открытый ключ) - это пара чисел [e, n], где n = p*q
    Приватный (закрытый ключ) - это пара чисел [d, n], где d вычисляется на основе p и q (= e^(-1) % phi(n), а phi(n) = (p-1)*(q-1))

    Но нужно сгенерировать случайное простое число, а для этого его ещё нужно и проверить, поэтогу разбиваем на подэтапы:
        Сгенерировать случайного "кандидата" нужного размера.
        Проверить, является ли кандидат простым числом. Если нет — возвращаемся к шагу 1.

        Теперь нужно определиться с размерами, добрый дядя клод чуть расписал всё это дело:

        Что касается размеров p и q, то здесь нужно понимать, что длина модуля n = p × q определяет криптографическую стойкость. 
        На данный момент минимально рекомендуемый размер RSA ключа составляет 2048 бит, что означает, что каждое из простых чисел 
        p и q должно быть примерно 1024 бита. Размер 1024 бита для всего модуля n уже считается небезопасным и не рекомендуется 
        для практического использования. Для повышенной безопасности используют 3072-битные ключи (p и q по ~1536 бит) или даже 
        4096-битные (p и q по ~2048 бит каждое).

        Так  как мы пока нубы возьмём 1024.

        Теперь генерация самих чисел. делать мы будем с помощь знакосого ПСП (но не тот что мы делали на миске, он нефига не криптостойкий),
        Будем юзать random_device, эта штука считывает системную энтропию, такую как движение мыши, шумы процессора, время между нажатиями клавиш
        и тд. Однако стоит учитывать, что на некоторых системах random_device может быть детерминированным, поэтому для криптографических целей 
        лучше использовать его в сочетании с криптографически стойким ГПСЧ (например, mt19937 с инициализацией от random_device).

        Плавненько переходим к переменным в которых это чудо будет хранится. Большие объёмы - битсет. Но облом, во первых он по базе статичен (хотя 
        есть boost::dynamic_bitset), но в нём сложно реализовать такие операии как сложения, вычитания, умножения и деления, которые критически 
        необходимы для RSA, так как он обладает базовыми побытовыми операциями (AND, OR, XOR, сдвиги). Переменные типа int long long тоже мимо, в
        них столько информации не  запихать. И вот на сцену выходят динамические массивы с данными, vector. Для его блоков возьмём uint 32 или 64. 
        И тут появляется логический вопрос, а сфигали? А вот так устроен процессор. Когда мы выполняем сложение, вычитание или умножение, процессор 
        работает с машинными словами - обычно это 32 или 64 бита на современных архитектурах. Если  приспичит делать на uint8 то для обработки того 
        же объема данных потребуется в 4-8 раз больше операций и циклов. Поэтому std::vector<uint32t> - наверное оптимальное решение (или 64).

        Что касается проверки на простоту, то для чисел такого размера детерминированные тесты становятся неэффективными. Слитшком много ресурсов 
        будет жрать система, нам такое не надо. Используются вероятностные тесты простоты, наиболее популярным из которых является тест Миллера-Рабина.
        Этот тест имеет вероятность ошибки не более 1/4^k, где k - количество раундов тестирования. Для криптографических целей обычно используют 
        достаточно раундов (например, 64), чтобы вероятность ошибки была пренебрежимо мала. (+ можно сразу генерировать нечёиные числа, чтобы увеличить 
        скорость генерации и уменьшить затраты).alignas

        Алгоритм генерации простых чисел для RSA выглядит примерно так: генерируем случайное нечетное число нужной длины (устанавливаем старший бит в 
        1 для гарантии длины и младший в 1 для нечетности), затем проверяете его на простоту тестом Миллера-Рабина. Если число составное, увеличиваете 
        его на 2 и повторяете проверку до тех пор, пока не найдете простое число.

        Важный момент - простые числа p и q должны удовлетворять определенным условиям безопасности: они не должны быть слишком близки друг к другу 
        (иначе возможна атака факторизации Ферма), разность p-1 и q-1 должна быть большой, и желательно, чтобы p-1 и q-1 имели большие простые делители 
        для защиты от некоторых специализированных атак.

        Для реализации модульной арифметики (возведение в степень по модулю, которое используется в RSA) применяется алгоритм быстрого возведения в 
        степень с модульной редукцией на каждом шаге. Это критически важно, поскольку промежуточные результаты могут быть огромными без модульной редукции.

        ну вроде всё описал, пока что. Lets go!
*/

#include <iostream>
#include <sstream>
#include <cstdint>
#include <iomanip>
#include <vector>
#include <random>

std::vector<uint64_t> degenerateRandomDigit(size_t len) {
    //Проверка на число длины 0
    if (len == 0) return std::vector<uint64_t>();

    //Считаем кол-во блоков, для простого числа длиной 1024 должно быть с учётом чисел в hex формате, 1024 / 64 = 16 блоков 
    size_t blockCount = (len + 63) / 64;

    //
    std::random_device rd;
    std::mt19937_64 gen(rd()); // 64-битный генератор Мерсенна
    std::uniform_int_distribution<uint64_t> dis(0, UINT64_MAX);

    std::vector<uint64_t> randomDigit(blockCount);

    //Заполняем все блоки
    for (int i = 0; i < blockCount; i++) {
        randomDigit[i] = dis(gen);
    }
    /*
        Вжух, экстренная вставка.
        Тут такой прикол, число номинально выглядит длиной 1024, но насамом деле таким может не являться. Чтобы понять чё тут происходит посмотрим на старший 
        бит этого числа, он должен быть равен 1. Это гарантирует, что число действительно занимает все 1024 бита.

        Прирер / пояснение:
        Представьте, что у вас есть 8-битное число. Если вы просто генерировать случайное число от 0 до 255, мы можем получить:
            11010110 (214 в десятичной) - это действительно 8-битное число
            01010110 (86 в десятичной) - это фактически 7-битное число
            00010110 (22 в десятичной) - это фактически 5-битное число

        В последних двух случаях число короче, чем мы хотели.

        Теперь рассморим мой косяк.
        Random digin of 1024 bits: 
        96163ee39427da46
        8dd41e70c1d2557f
        ...
        60bee698e1307b36
        Посмотрите на последний блок и переведем его в двоичный вид:
        60bee698e1307b36 = 0110 0000 1011 1110 1110 0110 1001 1000 1110 0001 0011 0000 0111 1011 0011 0110
        Вот тут то и проблемма, старший бит 0, а не 1, пара пара пам.

        Так что нужно делать обработку ласт блока.
    */
    return randomDigit;
}

/*
    Не ждали, а я снова тут. В общем ситуация такая, переделывать и усложнять функцию впадлу, добавлять флаги и тд - делать её нечитаемой и тд, идея не лучная, а вот разбить на 2 части 
    идея хорошая. Функция  то генерирует число нормально, но можно искусственно подогнать число под нужные условия. Они таковы: я уже говорил про длину, тут мы её сделвем, но можно ещё 
    сделать число нечётным, чтобы сразу исключить множество неверных вариантов. Для этого уже младшему биту присваиваем значение 1. Дёшево сердито.
*/

// Специализированная функция для RSA
std::vector<uint64_t> generatePrimeCandidate(size_t bitLength) {
    auto digit = degenerateRandomDigit(bitLength);
    
    // Устанавливаем старший бит
    size_t lastBlockIndex = (bitLength - 1) / 64;      // Находим индекс старшего блока
    size_t bitInLastBlock = (bitLength - 1) % 64;      // Находим позицию старшего бита
    digit[lastBlockIndex] |= (1ULL << bitInLastBlock); // Применяем маску в последнему биту
    
    // Устанавливаем младший бит
    digit[0] |= 1ULL;
    
    return digit;
}
/*
    Смотрим, что получилось. 
    Random digin of 1024 bits: 
    Block 0: be9ee8af7a938aa1
    Block 1: 98ea18c9e2aac6e1
    ...
    Block f: b6151d8cc32870d0
    В двоичтом виде:
    be9ee8af7a938aa1 = 1011 1110 1001 1110 1110 1000 1010 1111 0111 1010 1001 0011 1000 1010 1010 0001 тут всё хорошо, младший бит 1
    b6151d8cc32870d0 = 1011 0110 0001 0101 0001 1101 1000 1100 0011 0010 1000 0111 0000 0110 1100 0000 тут всё хорошо, старший бит 1
    Всё вроде рабоатет.
*/

// 
std::string vecToHexStr(const std::vector<uint64_t>& vec) {
    std::ostringstream oss;
    bool leadingZero = true; // Переменная для отслеживания ведущих нулей
    for (auto it = vec.rbegin(); it != vec.rend(); ++it) {
        if (leadingZero) {
            oss << std::hex << std::uppercase << *it; // Если ведущие нули есть, то не выводим их
            leadingZero = false; // Ведущие нули больше нет
        } else {
            oss << std::hex << std::uppercase << std::setw(16) << std::setfill('0') << *it; // Если ведущих нулей нет, то выводим их
        }
    }
    return oss.str();
}
/*
    Random digin of 1024 bits: 
Block 0: 1d4e37eddbe5134b
Block 1: 615a5570d24801b2
Block 2: 8247e1cb4a3e64f1
Block 3: b82cbf0efb05437f
Block 4: e25996d44a22f567
Block 5: 5ed99f0f021404d8
Block 6: 09f56d676dc6ae44
Block 7: ddd5bcddb00a5f12
Block 8: a7d89f3dc93f9663
Block 9: d6caff6ab56924d7
Block a: 68b18f39d31e6540
Block b: 8361eaee4f659b28
Block c: 31fe24ecf4e611a8
Block d: 68ac0cbc25684aa0
Block e: 7d3511e8c3c208e0
Block f: f06ded9c5f27d975

HEX: F06DED9C5F27D975
     7D3511E8C3C208E0
     68AC0CBC25684AA0
     31FE24ECF4E611A8
     8361EAEE4F659B28
     68B18F39D31E6540
     D6CAFF6AB56924D7
     A7D89F3DC93F9663
     DDD5BCDDB00A5F12
     09F56D676DC6AE44
     5ED99F0F021404D8
     E25996D44A22F567
     B82CBF0EFB05437F
     8247E1CB4A3E64F1
     615A5570D24801B2
     1D4E37EDDBE5134B

     Обычный порядок записи — от старшего к младшему, а for (auto i : randomDigit) выводит от младшего к старшему. Поэтому, чтобы openssl схавал что должен порядок должен быть от 
     старшего к младшему,
*/

bool isPrimeDigit(const std::string& hexStr, int rounds) {
    BN_CTX* ctx = BN_CTX_new();
    BIGNUM* bn = BN_new();
    bool is_prime = false;

    if (!BN_hex2bn(&bn, hexStr.c_str())) {
        std::cerr << "❌ Erroe: couldn't convert from HEX in BIGNUM!" << std::endl;
    } else {
        int result = BN_is_prime_ex(bn, rounds, ctx, nullptr);
        if (result == 1) {
            is_prime = true;
        } else if (result == 0) {
            std::cerr << "❌ Error: nomber in not prime!" << std::endl;
        } else {
            std::cerr << "⚠️ Simplicity unpacking error." << std::endl;
        }
    }

    BN_free(bn);
    BN_CTX_free(ctx);
    return is_prime;
}

std::vector<uint64_t> generatePrime(size_t bitLength, int rounds) {
    while (true) {
        auto candidate = generatePrimeCandidate(bitLength);
        std::string hexStr = vecToHexStr(candidate);
        if (isPrimeDigit(hexStr, rounds)) {
            return candidate;  // нашли простое — возвращаем
        }
    }
}

int main() {
    int n = 1024;
    /*
    //Создаём рандомный биг инт с нужной длиной
    std::cout << "Random digin of " << n << " bits: " << std::endl;
    auto randomDigit = generatePrimeCandidate(n);
    int count = 0;
    for (auto i : randomDigit) {
        std::cout << "Block " << count++ << ": " << std::hex <<std::setw(16) << std::setfill('0') << i << std::endl;
    }
    std::cout << std::endl;
    std::string hexStr = vecToHexStr(randomDigit);
    std::cout << "HEX: " << hexStr << std::endl;

    if (isPrimeDigit(hexStr, 64)) {
        std::cout << "✅ Number is prime!" << std::endl;
    } else {
        std::cout << "❌ Number is not prime!" << std::endl;
    }
    */

    //Подчистил мейн
    std::vector<uint64_t> primeDigit = generatePrime(n, 64);
    std::cout << "\n✅ Prime digit of " << n << " bits: " << std::endl;
    for (auto i : primeDigit) std::cout << std::hex <<std::setw(16) << std::setfill('0') << i << std::endl;
    
    return 0;
}
