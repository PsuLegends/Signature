================================================================================
// Файл: main.cpp
================================================================================

#include "UI/ui.h" // Предполагаем, что UI остался для парсинга аргументов
#include "Server/server.h" // Включаем новый класс Server
#include "Error/error.h"
#include <iostream>

int main(int argc, char* argv[]) {
    // UI теперь используется только для получения начальных параметров
    UI interface(argc, argv);
    uint16_t port = interface.get_port();
    std::string log_file_path = interface.get_log_loc();

    try {
        // Создаем единственный экземпляр Сервера
        Server server(port, log_file_path);
        // Метод run() теперь содержит бесконечный главный цикл
        server.run(); 
    } catch (const std::exception& e) {
        // Ловим любые критические исключения во время запуска
        std::cerr << "[FATAL] Не удалось запустить сервер: " << e.what() << std::endl;
        return 1; // Выход с кодом ошибки
    }

    return 0; // Эта точка никогда не будет достигнута для сервера, работающего бесконечно
}

================================================================================
// Файл: Client_handler/client_handler.cpp
================================================================================

#include "client_handler.h"
#include <iostream>
#include <unistd.h> // для close()
#include <arpa/inet.h> // для inet_ntop
#include <thread> // для sleep_for

// Включаем утилиты и протокол
#include "../Protocol_utils/protocol_utils.h"
#include "../Protocol/protocol.h"
#include "../Error/error.h"

// --- Реализация менеджера RAII ---
ClientConnectionManager::ClientConnectionManager(std::atomic<int>& counter)
    : client_counter(counter) {
    client_counter.fetch_add(1);
}

ClientConnectionManager::~ClientConnectionManager() {
    client_counter.fetch_sub(1);
}


// --- Реализация ClientHandler ---
ClientHandler::ClientHandler(int socket, sockaddr_in addr,
                             std::shared_ptr<AuthService> auth,
                             std::shared_ptr<SigningService> signing,
                             std::shared_ptr<logger> logger_instance,
                             const std::string& log_path,
                             std::atomic<int>& client_counter)
    : socket_fd(socket), auth_service(auth), signing_service(signing), 
      logger_ptr(logger_instance), log_location(log_path), 
      connection_manager(client_counter) // Счетчик увеличивается здесь
{
    char ip_buf[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &(addr.sin_addr), ip_buf, INET_ADDRSTRLEN);
    this->client_ip_str = ip_buf;
}

void ClientHandler::run() {
    try {
        // Логируем, что для нового клиента был запущен выделенный поток
        logger_ptr->write_log(log_location, "[INFO] [ClientHandler] Новый поток запущен для клиента " + client_ip_str);

        // --- ШАГ 0: ПРИВЕТСТВИЕ КЛИЕНТА (ИСПРАВЛЕНИЕ DEADLOCK'А) ---
        // Первым делом мы отправляем клиенту подтверждение, что соединение принято.
        // Теперь клиент знает, что можно начинать общение.
        if (ProtocolUtils::send_formatted_message(socket_fd, "CONN_ACCEPT", "server", -1, "Соединение успешно установлено.") != 0) {
            // Если мы не можем даже отправить приветствие, продолжать нет смысла.
            logger_ptr->write_log(log_location, "[WARN] [ClientHandler] Не удалось отправить приветствие клиенту " + client_ip_str + ". Закрытие соединения.");
            close(socket_fd);
            return;
        }

        // --- ШАГ 1: ПОЛУЧЕНИЕ НАЧАЛЬНОЙ ОПЕРАЦИИ ОТ КЛИЕНТА ---
        // Теперь, когда клиент получил наше приветствие, он отправит свой запрос.
        auto initial_msg_opt = ProtocolUtils::receive_and_parse_message(socket_fd);
        if (!initial_msg_opt) {
            // Если клиент отключается сразу после приветствия, это нормально. Просто логируем и выходим.
            logger_ptr->write_log(log_location, "[INFO] [ClientHandler] Клиент " + client_ip_str + " отсоединился до начала операции.");
            close(socket_fd);
            return;
        }

        // Распарсим полученное сообщение
        MessageProtocol::ParsedMessage initial_msg = *initial_msg_opt;
        this->client_id_str = initial_msg.clientID; // Сохраняем ID клиента для дальнейшего использования
        const std::string operation_type = initial_msg.header; // Тип операции (LOGIN или REGISTER)

        logger_ptr->write_log(log_location, "[INFO] [ClientHandler] Клиент " + client_id_str + " (" + client_ip_str + ") запрашивает операцию: " + operation_type);
        
        // --- ШАГ 2: ОБРАБОТКА РЕГИСТРАЦИИ ИЛИ АУТЕНТИФИКАЦИИ ---
        bool authenticated = false;
        if (operation_type == "REGISTER") {
            // Передаем управление сервису регистрации.
            // Соединение, как правило, закрывается после регистрации.
            auth_service->registerClient(socket_fd, client_id_str, client_ip_str);
        
        } else if (operation_type == "LOGIN") {
            // Передаем управление сервису аутентификации.
            if (auth_service->authenticateClient(socket_fd, client_id_str)) {
                authenticated = true; // Если аутентификация успешна, устанавливаем флаг
            }

        } else {
            logger_ptr->write_log(log_location, "[WARN] [ClientHandler] Неизвестная начальная операция: " + operation_type + " от клиента " + client_id_str);
            ProtocolUtils::send_formatted_message(socket_fd, "OP_UNKNOWN", client_id_str, -1, "Неизвестная начальная операция.");
        }

        // --- ШАГ 3: ОСНОВНОЙ ЦИКЛ ОБРАБОТКИ ЗАПРОСОВ (ЕСЛИ АУТЕНТИФИЦИРОВАН) ---
        if (authenticated) {
            logger_ptr->write_log(log_location, "[INFO] [ClientHandler] Клиент " + client_id_str + " аутентифицирован. Переход в режим обработки запросов.");
            processRequests();
        }

    } catch (const std::exception& e) {
        // Отлов любых непредвиденных исключений в потоке для предотвращения падения сервера
        logger_ptr->write_log(log_location, "[ERROR] [ClientHandler] Критическое исключение в потоке клиента " + client_id_str + " (" + client_ip_str + "): " + e.what());
    }

    // --- ШАГ 4: ЗАВЕРШЕНИЕ РАБОТЫ И ОЧИСТКА ---
    // Эта точка достигается либо после штатного завершения (выход, регистрация), либо из-за ошибки.
    // Сокет будет закрыт в любом случае.
    logger_ptr->write_log(log_location, "[INFO] [ClientHandler] Закрытие соединения и завершение потока для клиента " + client_id_str + " (" + client_ip_str + ").");
    close(socket_fd);
    
    // Деструктор ClientConnectionManager будет вызван автоматически при выходе из функции,
    // и счетчик активных клиентов уменьшится (принцип RAII).
}


void ClientHandler::processRequests() {
    while (true) {
        /*std::string packet_raw = ProtocolUtils::receive_packet(socket_fd, 1024);
        if (packet_raw.empty()) {
            logger_ptr->write_log(log_location, "[INFO] [ClientHandler] Клиент " + client_id_str + " отсоединился.");
            break;
        }*/

        auto request_opt = ProtocolUtils::receive_and_parse_message(socket_fd);
        if (!request_opt) {
            logger_ptr->write_log(log_location, "[INFO] [ClientHandler] Клиент " + client_id_str + " отсоединился.");
            break;
        }
        MessageProtocol::ParsedMessage request = *request_opt;
        const std::string& sig_op = request.header;

        if (sig_op == "SIGN_HASH") { // Замена для "11"
            handleSignOperation();
        } else if (sig_op == "GET_PUB_KEY") { // Замена для "22"
            handleGetPublicKeyOperation();
        } else if (sig_op == "LOGOUT") { // Замена для "0"
            logger_ptr->write_log(log_location, "[INFO] [ClientHandler] Клиент " + client_id_str + " запросил отключение.");
            break;
        } else {
            logger_ptr->write_log(log_location, "[WARN] [ClientHandler] Неизвестная операция подписи '" + sig_op + "' от " + client_id_str);
            ProtocolUtils::send_formatted_message(socket_fd, "OP_UNKNOWN", client_id_str, -1, "Неизвестная операция.");
        }
    }
}

void ClientHandler::handleSignOperation() {
    logger_ptr->write_log(log_location, "[INFO] [ClientHandler] " + client_id_str + " запрашивает подпись хеша.");
    auto hash_msg_opt = ProtocolUtils::receive_and_parse_message(socket_fd);
    if (!hash_msg_opt) {
        logger_ptr->write_log(log_location, "[WARN] [ClientHandler] " + client_id_str + " отсоединился перед отправкой хеша.");
        return;
    }
    // Предполагаем, что хеш находится в поле 'message'
    std::string hash_to_sign = hash_msg_opt->message;
    if(hash_to_sign.empty()){
        return;
    }
    
    try {
        std::string signature = signing_service->signHash(hash_to_sign);
        ProtocolUtils::send_formatted_message(socket_fd, "SIGN_SUCCESS", client_id_str, -1, signature);
    } catch (const SigningServiceError& e) {
        logger_ptr->write_log(log_location, "[ERROR] [ClientHandler] Ошибка подписи для " + client_id_str + ": " + e.what());
        ProtocolUtils::send_formatted_message(socket_fd, "SIGN_FAIL", client_id_str, -1, e.what());
    }
}

void ClientHandler::handleGetPublicKeyOperation() {
    logger_ptr->write_log(log_location, "[INFO] [ClientHandler] " + client_id_str + " запрашивает публичный ключ.");
    try {
        std::string n_hex = signing_service->getPublicKeyN_Hex();
        std::string e_hex = signing_service->getPublicKeyE_Hex();

        // Отправляем части ключа в раздельных сообщениях
        ProtocolUtils::send_formatted_message(socket_fd, "PUB_KEY_N", client_id_str, -1, n_hex);
        std::this_thread::sleep_for(std::chrono::milliseconds(20)); // Пауза для надежности
        ProtocolUtils::send_formatted_message(socket_fd, "PUB_KEY_E", client_id_str, -1, e_hex);
        
    } catch (const SigningServiceError& e) {
        logger_ptr->write_log(log_location, "[ERROR] [ClientHandler] Ошибка получения публичного ключа для " + client_id_str + ": " + e.what());
        ProtocolUtils::send_formatted_message(socket_fd, "KEY_FAIL", client_id_str, -1, e.what());
    }
}


================================================================================
// Файл: Client_handler/client_handler.h
================================================================================

#pragma once

#include <string>
#include <memory>
#include <atomic>
#include <netinet/in.h>

// Зависимости от сервисов, которые будут использоваться
#include "../Auth_reg/auth_service.h"
#include "../Signing/signing_service.h"
#include "../Logger/logger.h"

// Класс для управления жизненным циклом счетчика клиентов (RAII)
class ClientConnectionManager {
public:
    explicit ClientConnectionManager(std::atomic<int>& counter);
    ~ClientConnectionManager();
private:
    std::atomic<int>& client_counter;
};


class ClientHandler {
public:
    ClientHandler(int socket, sockaddr_in addr,
                  std::shared_ptr<AuthService> auth,
                  std::shared_ptr<SigningService> signing,
                  std::shared_ptr<logger> logger_instance,
                  const std::string& log_path,
                  std::atomic<int>& client_counter);

    // Точка входа, которая будет выполняться в новом потоке
    void run();

private:
    // Основная логика обработки
    void processRequests();
    std::string receive_buffer;
    // Методы для обработки конкретных операций
    void handleSignOperation();
    void handleGetPublicKeyOperation();
    std::string receive_one_message();
    int socket_fd;
    std::string client_ip_str;
    std::string client_id_str;
    std::string log_location;
    
    // Указатели на общие сервисы
    std::shared_ptr<AuthService> auth_service;
    std::shared_ptr<SigningService> signing_service;
    std::shared_ptr<logger> logger_ptr;
    
    // Менеджер соединения, использующий RAII
    ClientConnectionManager connection_manager;
};

================================================================================
// Файл: Protocol_utils/protocol_utils.cpp
================================================================================

// Файл: Protocol_utils/protocol_utils.cpp (НОВАЯ РЕАЛИЗАЦИЯ)

#include "protocol_utils.h"

// Необходимые системные заголовочные файлы
#include <sys/socket.h>
#include <unistd.h>
#include <vector>
#include <iostream>
#include <arpa/inet.h> // Для htonl, ntohl
#include <stdexcept>

namespace ProtocolUtils {

    // --- Приватные вспомогательные функции (они теперь основа) ---
    namespace {

        /**
         * @brief Надежно отправляет весь буфер данных в сокет.
         */
        int send_all(int socket, const char* buffer, size_t length) {
            size_t total_sent = 0;
            while (total_sent < length) {
                ssize_t sent_now = ::send(socket, buffer + total_sent, length - total_sent, MSG_NOSIGNAL);
                if (sent_now <= 0) {
                    perror("send_all failed");
                    return -1; // Ошибка или разрыв соединения
                }
                total_sent += sent_now;
            }
            return 0; // Успех
        }

        /**
         * @brief Надежно читает ровно `bytes_to_receive` байт из сокета.
         * Использует MSG_WAITALL для эффективности.
         * @return Строка с данными или пустая строка при ошибке/разрыве соединения.
         */
        std::string receive_all(int socket, size_t bytes_to_receive) {
            if (bytes_to_receive == 0) return "";
            
            std::string buffer(bytes_to_receive, '\0');
            ssize_t bytes_read = ::recv(socket, &buffer[0], bytes_to_receive, MSG_WAITALL);
            
            if (bytes_read != static_cast<ssize_t>(bytes_to_receive)) {
                // Если мы не получили ровно столько, сколько просили, это ошибка или разрыв.
                return "";
            }
            
            return buffer;
        }

    } // конец анонимного namespace

    // --- Реализация публичных функций с НОВОЙ логикой ---

    int send_formatted_message(int socket, const std::string& header, const std::string& client_id, int msg_id, const std::string& message) {
        // 1. Формируем тело сообщения (как и раньше)
        std::string body = MessageProtocol::build(header, client_id, msg_id, message);
        
        // 2. Получаем его длину и конвертируем в 4-байтовое сетевое число
        uint32_t len = body.length();
        uint32_t network_len = htonl(len); // Host-To-Network-Long
        
        // 3. Отправляем 4 байта с длиной
        if (send_all(socket, reinterpret_cast<const char*>(&network_len), sizeof(network_len)) != 0) {
            std::cerr << "[ProtocolUtils] Ошибка отправки длины сообщения." << std::endl;
            return -1;
        }

        // 4. Отправляем само тело сообщения
        if (send_all(socket, body.data(), body.size()) != 0) {
            std::cerr << "[ProtocolUtils] Ошибка отправки тела сообщения." << std::endl;
            return -1;
        }

        return 0; // Успех
    }
    

    std::optional<MessageProtocol::ParsedMessage> receive_and_parse_message(int socket) {
        // 1. Читаем ровно 4 байта, чтобы узнать длину
        uint32_t network_len = 0;
        std::string len_bytes = receive_all(socket, sizeof(network_len));
        if (len_bytes.size() != sizeof(network_len)) {
            // Соединение разорвано
            return std::nullopt;
        }
        network_len = *reinterpret_cast<const uint32_t*>(len_bytes.data());

        // 2. Конвертируем из сетевого порядка в хостовый
        uint32_t body_len = ntohl(network_len);
        
        // Проверка на адекватность размера (защита от DoS-атак с огромным размером)
        const size_t MAX_MSG_SIZE = 1024 * 1024; // 1 MB, например
        if (body_len > MAX_MSG_SIZE) {
            std::cerr << "[ProtocolUtils] Ошибка: получена слишком большая длина сообщения: " << body_len << std::endl;
            return std::nullopt;
        }

        // 3. Читаем ровно `body_len` байт тела сообщения
        std::string body = receive_all(socket, body_len);
        if (body.size() != body_len) {
            // Соединение разорвано при чтении тела
            return std::nullopt;
        }

        // 4. Парсим тело и возвращаем
        try {
            return MessageProtocol::parse(body);
        } catch (const std::exception& e) {
            std::cerr << "[ProtocolUtils] Ошибка парсинга тела сообщения: " << e.what() << std::endl;
            return std::nullopt;
        }
    }

} // namespace ProtocolUtils

================================================================================
// Файл: Protocol_utils/protocol_utils.h
================================================================================

// Файл: Protocol_utils/protocol_utils.h (остается без изменений)
#pragma once

#include <string>
#include <optional>
#include "../Protocol/protocol.h" 

namespace ProtocolUtils {

    /**
     * @brief Высокоуровневая функция для отправки сообщения по протоколу.
     * @details (Внутренняя реализация теперь использует 4 байта длины + тело).
     * @return 0 в случае успеха, -1 в случае ошибки.
     */
    int send_formatted_message(int socket, const std::string& header, const std::string& client_id, int msg_id, const std::string& message);

    /**
     * @brief Высокоуровневая функция для приема сообщения по протоколу.
     * @details (Внутренняя реализация теперь использует 4 байта длины + тело).
     * @return Распарсированная полезная нагрузка. std::nullopt при ошибке.
     */
    std::optional<MessageProtocol::ParsedMessage> receive_and_parse_message(int socket);

    // Старые send_packet/receive_packet можно оставить как приватные или удалить,
    // если они больше нигде не используются напрямую. Для чистоты лучше убрать.
}

================================================================================
// Файл: Signing/signing_service.cpp
================================================================================

#include "signing_service.h"

// Подключаем наши утилитарные функции для RSA
// Путь нужно будет скорректировать под вашу структуру.
#include "../Rsa/rsa_crypto.h"

#include <iostream> // для вывода в консоль
#include <vector>

/**
 * @brief Конструктор сервиса подписи. Сразу же пытается загрузить ключи.
 */
SigningService::SigningService(const std::string& private_key_path,
                               const std::string& public_key_n_path,
                               const std::string& public_key_e_path) 
{
    // Обертываем загрузку ключей в блок try-catch,
    // чтобы обработать ошибки и кинуть наше кастомное исключение.
    try {
        std::cout << "[INFO] [SigningService] Загрузка ключей..." << std::endl;
        
        // Используем вспомогательную функцию из RSA-модуля для загрузки.
        // Предполагается, что она кидает std::exception в случае ошибки.
        d_key = loadKeyFromFile(private_key_path);
        n_key = loadKeyFromFile(public_key_n_path);
        e_key = loadKeyFromFile(public_key_e_path);

        keys_are_loaded = true;
        std::cout << "[INFO] [SigningService] Ключи успешно загружены." << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "[CRITICAL] [SigningService] Не удалось загрузить ключи: " << e.what() << std::endl;
        // Кидаем наше собственное, более специфичное исключение, которое
        // может быть поймано на более высоком уровне (например, в классе Server).
        throw SigningServiceError("Ошибка при инициализации сервиса подписи: " + std::string(e.what()));
    }
}

/**
 * @brief Подписывает предоставленный хеш.
 */
std::string SigningService::signHash(const std::string& hex_hash) const {
    if (!keys_are_loaded) {
        throw SigningServiceError("Невозможно подписать хеш: ключи не были загружены.");
    }

    std::cout << "[INFO] [SigningService] Начало процесса подписи для хеша: " << hex_hash << std::endl;

    // 1. Конвертируем полученный HEX-хеш в вектор байт
    std::vector<unsigned char> byte_vector = hexStringToBytes(hex_hash);

    // 2. Преобразуем вектор байт в объект BigInt
    BigInt hash_as_bigint = fromBytes(byte_vector);

    // 3. Создаем подпись (шифруем хеш с помощью закрытого ключа d и модуля n)
    BigInt signature = rsa_mod_exp(hash_as_bigint, d_key, n_key);
    
    // 4. Конвертируем объект подписи BigInt в HEX-строку для возврата
    std::string signature_hex = signature.toHexString();
    
    std::cout << "[INFO] [SigningService] Сгенерирована подпись: " << signature_hex << std::endl;

    return signature_hex;
}

/**
 * @brief Возвращает компонент N публичного ключа.
 */
std::string SigningService::getPublicKeyN_Hex() const {
    if (!keys_are_loaded) {
        throw SigningServiceError("Невозможно получить ключ N: ключи не были загружены.");
    }
    return n_key.toHexString();
}

/**
 * @brief Возвращает компонент E публичного ключа.
 */
std::string SigningService::getPublicKeyE_Hex() const {
    if (!keys_are_loaded) {
        throw SigningServiceError("Невозможно получить ключ E: ключи не были загружены.");
    }
    return e_key.toHexString();
}

================================================================================
// Файл: Signing/signing_service.h
================================================================================

#pragma once

#include <string>
#include <stdexcept>

// Подключаем наш модуль для работы с RSA.
// Путь нужно будет скорректировать под вашу структуру.
#include "../Rsa/rsa_crypto.h" 

// Определяем кастомное исключение для ошибок сервиса подписи
class SigningServiceError : public std::runtime_error {
public:
    explicit SigningServiceError(const std::string& message) : std::runtime_error(message) {}
};

class SigningService {
public:
    /**
     * @brief Конструктор сервиса подписи.
     * @param private_key_path Путь к файлу с приватным ключом (d).
     * @param public_key_n_path Путь к файлу с компонентом N публичного ключа.
     * @param public_key_e_path Путь к файлу с компонентом E публичного ключа.
     */
    SigningService(const std::string& private_key_path, 
                   const std::string& public_key_n_path, 
                   const std::string& public_key_e_path);

    /**
     * @brief Подписывает предоставленный хеш.
     * @param hex_hash Хеш данных, представленный в виде HEX-строки.
     * @return Электронная подпись в виде HEX-строки.
     * @throw SigningServiceError если ключи не были загружены.
     */
    std::string signHash(const std::string& hex_hash) const;

    /**
     * @brief Возвращает компонент N публичного ключа.
     * @return Компонент N в виде HEX-строки.
     * @throw SigningServiceError если ключи не были загружены.
     */
    std::string getPublicKeyN_Hex() const;

    /**
     * @brief Возвращает компонент E публичного ключа.
     * @return Компонент E в виде HEX-строки.
     * @throw SigningServiceError если ключи не были загружены.
     */
    std::string getPublicKeyE_Hex() const;

private:
    /**
     * @brief Внутренняя функция для загрузки всех ключей с диска.
     * @throw SigningServiceError если какой-либо из файлов ключей не может быть загружен.
     */
    void loadKeys();

    // Хранилища для ключей
    BigInt d_key; // Приватный ключ
    BigInt n_key; // Модуль (часть публичного ключа)
    BigInt e_key; // Экспонента (часть публичного ключа)
    
    // Флаг, показывающий, были ли ключи успешно загружены
    bool keys_are_loaded = false;
};

================================================================================
// Файл: Base/database.cpp
================================================================================

#include "database.h"

base::base() {
    // Попытка подключения к базе данных "client_base.db" при создании объекта.
    if (!connectToDatabase("client_base.db")) {
        // Если подключение не удалось, выводим критическую ошибку в журнал
        qCritical() << "Не удалось подключиться к базе данных.";
    }
}

// Подключение к базе данных
bool base::connectToDatabase(const std::string& dbName) {
    // Проверяем существование файла базы данных
    QFileInfo dbFile(QString::fromStdString(dbName));
    if (!dbFile.exists() || !dbFile.isFile()) {
        qCritical() << "Ошибка: файл базы данных не найден:" << QString::fromStdString(dbName);
        exit(1);
        return false;
    }

    // Устанавливаем имя базы данных для объекта db
    db.setDatabaseName(QString::fromStdString(dbName));
    
    // Пытаемся открыть соединение с базой данных
    if (!db.open()) {
        // Если не удалось подключиться, выводим ошибку и возвращаем false
        printQueryError(query, "CONNECT");
        return false;
    }
    
    // Если подключение успешно, выводим сообщение
    qDebug() << "Подключение к базе данных успешно.";
    return true;
}


// Функция для вставки нового пользователя в таблицу
bool base::insertUser(const std::string& username, const std::string& password, const std::string& ip) {
    // Подготавливаем SQL-запрос для вставки данных пользователя в таблицу "users"
    query.prepare("INSERT INTO users (username, password, ip) VALUES (:username, :password, :ip)");
    
    // Привязываем значения параметров к запросу
    query.bindValue(":username", QString::fromStdString(username));
    query.bindValue(":password", QString::fromStdString(password));
    query.bindValue(":ip", QString::fromStdString(ip));

    // Выполняем запрос на выполнение
    if (!query.exec()) {
        // Если запрос не выполнен, выводим ошибку и возвращаем false
        printQueryError(query, "INSERT");
        return false;
    }
    
    // Если запрос успешен, выводим сообщение о добавлении пользователя
    qDebug() << "Пользователь успешно добавлен.";
    return true;
}
// Функция для выбора пользователя по имени
bool base::selectUserByName(std::string name) {
    // Подготавливаем SQL-запрос для выбора пользователя по имени
    query.prepare("SELECT * FROM users WHERE username = :name");
    query.bindValue(":name", QString::fromStdString(name));

    // Выполняем запрос
    if (!query.exec()) {
        // Если запрос не выполнен, выводим ошибку и возвращаем false
        printQueryError(query, "SELECT");
        return false;
    }

    // Если пользователь найден, извлекаем его данные
    if (query.next()) {
        int userId = query.value(0).toInt();       // Извлекаем ID пользователя
        QString username = query.value(1).toString();  // Извлекаем имя пользователя
        QString password = query.value(2).toString();  // Извлекаем пароль пользователя
        QString ip = query.value(3).toString();      // Извлекаем IP пользователя

        // Сохраняем текущие значения
        current_ip_ = ip.toStdString();
        current_hashed_password_ = password.toStdString();

        // Логируем информацию о пользователе
        qDebug() << "ID: " << userId << "Username: " << username << "Password: " << password << "IP: " << ip;
        return true;
    } else {
        // Если пользователь не найден, выводим соответствующее сообщение
        qDebug() << "Пользователь не найден.";
        return false;
    }
}
// Функция для получения текущего IP
std::string base::getCurrentIP() const {
    return current_ip_;  // Возвращает текущий IP пользователя
}

// Функция для получения текущего хешированного пароля
std::string base::getCurrentHashedPassword() const {
    return current_hashed_password_;  // Возвращает текущий хешированный пароль пользователя
}

// Функция для вывода ошибки SQL-запроса
void base::printQueryError(const QSqlQuery& query, const std::string& queryType) {
    // Выводит сообщение об ошибке, связанной с выполнением SQL-запроса
    qCritical() << "Ошибка SQL-запроса типа:" << QString::fromStdString(queryType)
                << "с сообщением:" << query.lastError().text();
}


================================================================================
// Файл: Base/database.h
================================================================================

#pragma once
#include <string>
#include <vector>
#include <memory>
#include "../Logger/logger.h"
#include <filesystem>
#include <QCoreApplication>
#include <QSqlDatabase>
#include <QSqlQuery>
#include <QSqlError>
#include <QDebug>
#include <QFileInfo>
#include <QString>
#include <QDebug>
class base {
private:
    QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE");
    QSqlQuery query;

public:
    base();
    bool connectToDatabase(const std::string& dbName);
    bool insertUser(const std::string& username, const std::string& password, const std::string& ip);
    bool selectUserByName(std::string name);
    void printQueryError(const QSqlQuery& query, const std::string& queryType);
    std::string current_ip_;
    std::string current_hashed_password_;
    std::string getCurrentIP() const;
    std::string getCurrentHashedPassword() const;
};


================================================================================
// Файл: Error/error.h
================================================================================

#pragma once
#include <stdexcept>
#include <string>
/** Класс ошибок
*  Используется для отлова специфических ошибок, возникающих в ходе работы модулей
*  В конструкторе указывается строка с сообщением ошибки
*/
class critical_error:public std::runtime_error{
    public:
    /** Конструктор ошибки
    * s Сообщение об ошибке
    */
    critical_error(const std::string& s):std::runtime_error(s){}
};

================================================================================
// Файл: Crypto_utils/crypto_utils.cpp
================================================================================

#include "crypto_utils.h"

// --- Заголовочные файлы Crypto++ ---
// Для хеширования (SHA-256)
#include "cryptopp/sha.h"

// Для генерации случайных чисел
#include "cryptopp/osrng.h" // AutoSeededRandomPool

// Для кодирования/декодирования и работы с потоками данных
#include "cryptopp/filters.h" // StringSource, HashFilter, ...
#include "cryptopp/hex.h"     // HexEncoder
#include "cryptopp/secblock.h" // SecByteBlock


namespace CryptoUtils {

// Реализация функции хеширования
std::string generate_hash(const std::string& input) {
    // 1. Создаем объект алгоритма хеширования SHA-256.
    CryptoPP::SHA256 hash_algorithm;

    // 2. Создаем строку, которая будет хранить результат в виде дайджеста.
    std::string digest;

    // 3. Создаем "конвейер" для обработки данных:
    //    - StringSource: Источник данных - наша входная строка 'input'.
    //    - HashFilter: Фильтр, который применяет к данным 'hash_algorithm'.
    //    - HexEncoder: Кодировщик, который преобразует бинарный дайджест в HEX-строку.
    //    - StringSink: "Приемник" данных, который помещает результат в строку 'digest'.
    //    Параметр 'true' в StringSource означает "putNextMessage".
    CryptoPP::StringSource(input, true, 
        new CryptoPP::HashFilter(hash_algorithm,
            new CryptoPP::HexEncoder(
                new CryptoPP::StringSink(digest)
            )
        )
    );

    return digest;
}


// Реализация функции генерации случайной строки
std::string generate_random_hex_string(size_t byte_length) {
    // 1. Создаем объект криптографически стойкого генератора псевдослучайных чисел (CSPRNG).
    //    AutoSeededRandomPool автоматически "засеивается" энтропией из операционной системы,
    //    что делает его непредсказуемым.
    CryptoPP::AutoSeededRandomPool prng;

    // 2. Создаем безопасный блок байт (SecByteBlock) для хранения случайных данных.
    //    SecByteBlock автоматически обнуляет память при уничтожении, чтобы
    //    предотвратить утечку чувствительных данных.
    CryptoPP::SecByteBlock random_bytes(byte_length);
    
    // 3. Заполняем блок случайными данными.
    prng.GenerateBlock(random_bytes, random_bytes.size());

    // 4. Кодируем сырые байты в шестнадцатеричную строку.
    std::string hex_encoded_string;
    CryptoPP::StringSource(random_bytes, random_bytes.size(), true,
        new CryptoPP::HexEncoder(
            new CryptoPP::StringSink(hex_encoded_string)
        )
    );

    return hex_encoded_string;
}

} // namespace CryptoUtils

================================================================================
// Файл: Crypto_utils/crypto_utils.h
================================================================================

// crypto_utils.h
#pragma once
#include <string>

namespace CryptoUtils {
    // Хеширует строку с помощью SHA-256 и возвращает HEX
    std::string generate_hash(const std::string& input);

    // Генерирует крипто-стойкую случайную HEX-строку
    std::string generate_random_hex_string(size_t byte_length);
}

================================================================================
// Файл: Server/server.cpp
================================================================================

#include "server.h"
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <thread>
#include "../Client_handler/client_handler.h" // Важно

Server::Server(uint16_t port, const std::string& log_path)
    : port(port), log_location(log_path)
{
    try {
        // Инициализация сервисов (Внедрение зависимостей)
        logger_ptr = std::make_shared<logger>();
        logger_ptr->write_log(log_location, "[INFO] [Server] Инициализация сервера...");
        
        db_ptr = std::make_shared<base>(); // Конструктор 'base' уже выполняет подключение
        
        auth_service_ptr = std::make_shared<AuthService>(*db_ptr, *logger_ptr, log_location);
        
        // Пути к ключам должны приходить из конфига, пока задаем их здесь
        signing_service_ptr = std::make_shared<SigningService>("private.key", "public_n.key", "public_e.key");

        logger_ptr->write_log(log_location, "[INFO] [Server] Все сервисы успешно инициализированы.");
    } catch (const std::exception& e) {
        if(logger_ptr) {
            logger_ptr->write_log(log_location, std::string("[CRITICAL] [Server] Ошибка инициализации: ") + e.what());
        }
        std::cerr << "[CRITICAL] [Server] Ошибка инициализации: " << e.what() << std::endl;
        throw; // Перебрасываем исключение, чтобы завершить программу
    }
}

void Server::run() {
    setup();
    acceptLoop();
}

void Server::setup() {
    logger_ptr->write_log(log_location, "[INFO] [Server] Настройка сокета...");
    server_socket_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket_fd < 0) {
        throw critical_error("Ошибка при создании сокета сервера.");
    }

    sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(port);
    serverAddr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket_fd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {
        throw critical_error("Ошибка bind() для порта " + std::to_string(port));
    }

    if (listen(server_socket_fd, 10) != 0) {
        throw critical_error("Ошибка listen()");
    }
    
    logger_ptr->write_log(log_location, "[INFO] [Server] Сервер слушает порт " + std::to_string(port));
    std::cout << "[INFO] [Server] Сервер слушает порт " << std::to_string(port) << std::endl;
}

void Server::acceptLoop() {
    logger_ptr->write_log(log_location, "[INFO] [Server] Вход в цикл принятия соединений...");
    while (true) {
        sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        int client_socket = accept(server_socket_fd, (struct sockaddr*)&client_addr, &client_len);

        if (client_socket < 0) {
            logger_ptr->write_log(log_location, "[ERROR] [Server] accept() завершился с ошибкой.");
            continue; 
        }

        // Проверка лимита клиентов
        if (active_clients >= MAX_CLIENTS) {
            logger_ptr->write_log(log_location, "[WARN] [Server] Достигнут лимит клиентов. Новое соединение отклонено.");
            // Отправим отказ и закроем. Это единственное сообщение, которое здесь уместно.
            ProtocolUtils::send_formatted_message(client_socket, "CONN_REJECT", "server", -1, "Сервер занят. Попробуйте позже.");
            close(client_socket);
            continue;
        }

        // Логику успешного соединения переносим в ClientHandler
        // Больше не отправляем "CONN_ACCEPT" и не логируем здесь
        
        // Создаем и запускаем ClientHandler в новом потоке
        auto handler = std::make_shared<ClientHandler>(client_socket, client_addr, 
                                                       auth_service_ptr, signing_service_ptr, 
                                                       logger_ptr, log_location, active_clients);

        std::thread client_thread([handler]() {
            handler->run();
        });
        
        client_thread.detach(); 
    }
}

================================================================================
// Файл: Server/server.h
================================================================================

#pragma once

#include <string>
#include <atomic>
#include <memory>
#include <netinet/in.h> // Для sockaddr_in

// Зависимости от новых модулей-сервисов
#include "../Logger/logger.h"
#include "../Base/database.h" // Используем ваше имя класса 'base'
#include "../Auth_reg/auth_service.h"
#include "../Signing/signing_service.h"
#include "../Error/error.h"
#include "../Protocol_utils/protocol_utils.h"
class Server {
public:
    /**
     * @brief Конструктор сервера.
     * @param port Порт, на котором сервер будет слушать.
     * @param log_path Путь к лог-файлу.
     */
    Server(uint16_t port, const std::string& log_path);

    /**
     * @brief Запускает сервер и входит в цикл принятия соединений.
     */
    void run();

private:
    /**
     * @brief Выполняет начальную настройку сокета (socket, bind, listen).
     */
    void setup();

    /**
     * @brief Главный цикл, принимающий новые клиентские соединения.
     */
    void acceptLoop();

    // Конфигурация и состояние сервера
    uint16_t port;
    int server_socket_fd = -1;
    std::string log_location;
    std::atomic<int> active_clients{0};
    const int MAX_CLIENTS = 3; // Лимит одновременных клиентов

    // Общие сервисы, которые будут "внедряться" в обработчики клиентов
    std::shared_ptr<logger> logger_ptr;
    std::shared_ptr<base> db_ptr;
    std::shared_ptr<AuthService> auth_service_ptr;
    std::shared_ptr<SigningService> signing_service_ptr;
};

================================================================================
// Файл: UI/ui.cpp
================================================================================

#include "ui.h"
#include <boost/program_options.hpp>
namespace po = boost::program_options;
UI::UI(int argc, char* argv[]) {
    // Добавление опций командной строки
    desc.add_options()
        ("help,h", "Помощь")  // Опция для вывода справки
        ("Log_loc,l", po::value<std::vector<std::string>>()->multitoken(), "Путь для log файла")  // Опция для указания пути к лог-файлу
        ("Port,p", po::value<std::vector<uint>>()->multitoken(), "Порт сервера(1025-65534)");  // Опция для указания портов сервера

    try {
        // Парсинг командной строки
        po::store(po::parse_command_line(argc, argv, desc), vm);

        // Если указана опция "help" или отсутствуют обязательные параметры ("Log_loc" или "Port"), выводим справку и завершаем программу
        if (vm.count("help") || !vm.count("Log_loc") || !vm.count("Port")) {
            std::cout << desc << std::endl;
            exit(0);  // Выход из программы, если не все параметры указаны
        }

        // Применяем опции, если парсинг прошел успешно
        po::notify(vm);
    } catch (po::error& e) {
        // Обработка ошибок парсинга опций
        std::cout << e.what() << std::endl;
    }
    catch(critical_error &e){
        // Обработка критических ошибок
        std::cout << "Критическая ошибка: " << e.what() << std::endl;
    }
}
uint UI::get_port()
{
    if (vm.count("Port") and !vm["Port"].as<std::vector<uint>>().empty())
    {
        const std::vector<uint> &ports = vm["Port"].as<std::vector<uint>>();
        
        // Проверка на допустимые значения диапазона портов
        if (ports.back() < 1024)
        {
            std::cout<<"Неверное значение порта"<<std::endl;
            std::cout << desc << std::endl;
            exit(0); 
            return 1;
        }
        if (ports.back() > 65535)
        {
            std::cout<<"Неверное значение порта"<<std::endl;
            std::cout << desc << std::endl;
            exit(0); 
            return 1;
        }

        return ports.back();
    }
    else
    {
        // Если порт не передан — выводим справку и сообщение об ошибке
        std::cout << desc << std::endl;
        return 1;
    }
}

std::string UI::get_log_loc() {
    // Проверка, была ли указана опция "Log_loc"
    if (vm.count("Log_loc")) {
        const std::vector<std::string>& log_loc = vm["Log_loc"].as<std::vector<std::string>>();  // Извлекаем путь к лог-файлу
        return log_loc.back();  // Возвращаем последний указанный путь
    } else {
        return "";  // Если путь не указан, возвращаем пустую строку
    }
}


================================================================================
// Файл: UI/ui.h
================================================================================


#pragma once
#include <boost/program_options.hpp>
#include <iostream>
#include <string>
#include <vector>

#include "../Error/error.h"
#include "../Logger/logger.h"
namespace po = boost::program_options;
class UI
{
private:
    uint port;
    std::string base_loc;
public:
    logger log;
    po::options_description desc;
    po::variables_map vm;
    std::string log_loc;
    UI(int argc, char* argv[]);
    uint get_port();
    std::string get_log_loc();
};

================================================================================
// Файл: Auth_reg/auth_service.cpp
================================================================================

#include "auth_service.h"

#include <iostream>

// Подключаем утилиты и протокол
#include "../Crypto_utils/crypto_utils.h"
#include "../Protocol/protocol.h"
#include "../Protocol_utils/protocol_utils.h"
#include "../Error/error.h"

// --- Конструктор ---
AuthService::AuthService(base& db, logger& logger_instance, const std::string& log_path)
    : db_ref(db), logger_ref(logger_instance), log_location(log_path) 
{
    logger_ref.write_log(log_location, "[INFO] [AuthService] Сервис аутентификации и регистрации инициализирован.");
}


// --- Аутентификация ---
bool AuthService::authenticateClient(int socket, const std::string& client_id) {
    const std::string log_prefix = "[AuthService] [Authenticate] | ClientID: " + client_id + " | ";

    // 1. ВЫБИРАЕМ пользователя и ЗАГРУЖАЕМ его данные в объект db_ref
    if (!db_ref.selectUserByName(client_id)) {
        logger_ref.write_log(log_location, log_prefix + "Failure - User not found in database.");
        std::cerr << "[WARN] " << log_prefix << "Попытка входа для несуществующего пользователя." << std::endl;
        
        // БЫЛО:
        // std::string packet = MessageProtocol::build("AUTH_FAIL", client_id, -1, "User not found");
        // ProtocolUtils::send_packet(socket, packet);
        
        // СТАЛО:
        ProtocolUtils::send_formatted_message(socket, "AUTH_FAIL", client_id, -1, "User not found");
        return false;
    }

    // --- Логика Challenge-Response остается прежней ---

    // 2. Генерируем "Вызов" (nonce)
    std::string nonce = CryptoUtils::generate_random_hex_string(16);
    {
        std::lock_guard<std::mutex> lock(challenges_mutex);
        active_challenges[socket] = nonce;
    }

    // 3. Отправляем nonce клиенту
    logger_ref.write_log(log_location, log_prefix + "Sending challenge.");
    if (ProtocolUtils::send_formatted_message(socket, "CHALLENGE", "server", -1, nonce) != 0) {
        logger_ref.write_log(log_location, log_prefix + "Failure - Could not send challenge packet.");
        removeChallenge(socket);
        return false;
    }

    // 4. Получаем "Ответ" от клиента
    auto response_opt = ProtocolUtils::receive_and_parse_message(socket);
    if (!response_opt) {
        logger_ref.write_log(log_location, log_prefix + "Failure - Client disconnected before sending response.");
        removeChallenge(socket);
        return false;
    }
    std::string client_response = response_opt->message;
    
    // 5. Проверяем "Ответ"
    std::string password_hash_from_db = db_ref.getCurrentHashedPassword();
    if (password_hash_from_db.empty()) {
        logger_ref.write_log(log_location, log_prefix + "Critical Failure - User found, but no password hash available.");
        // Отправляем ошибку клиенту
        ProtocolUtils::send_formatted_message(socket, "AUTH_FAIL", client_id, -1, "Internal server error");
        removeChallenge(socket);
        return false;
    }
    
    std::string expected_response = CryptoUtils::generate_hash(password_hash_from_db + nonce);
    removeChallenge(socket);

    if (client_response == expected_response) {
        // Успех!
        logger_ref.write_log(log_location, log_prefix + "Success - Authentication successful.");
        std::cout << "[INFO] " << log_prefix << "Аутентификация прошла успешно." << std::endl;

        // БЫЛО:
        // std::string ok_packet = MessageProtocol::build("AUTH_OK", client_id, -1, "Authentication successful");
        // ProtocolUtils::send_packet(socket, ok_packet);

        // СТАЛО:
        ProtocolUtils::send_formatted_message(socket, "AUTH_OK", client_id, -1, "Authentication successful");
        return true;
    } else {
        // Неудача
        logger_ref.write_log(log_location, log_prefix + "Failure - Invalid response.");
        std::cerr << "[WARN] " << log_prefix << "Неверный ответ на 'вызов'." << std::endl;
        
        // БЫЛО:
        // std::string fail_packet = MessageProtocol::build("AUTH_FAIL", client_id, -1, "Invalid credentials");
        // ProtocolUtils::send_packet(socket, fail_packet);

        // СТАЛО:
        ProtocolUtils::send_formatted_message(socket, "AUTH_FAIL", client_id, -1, "Invalid credentials");
        return false;
    }
}


// --- Регистрация ---
bool AuthService::registerClient(int socket, const std::string& client_id, const std::string& client_ip) {
    const std::string log_prefix = "[AuthService] [Register] | ClientID: " + client_id + " | IP: " + client_ip + " | ";
    
    // 1. Проверяем, не занят ли ID
    if (db_ref.selectUserByName(client_id)) {
        logger_ref.write_log(log_location, log_prefix + "Failure - User ID already exists.");
        std::cerr << "[WARN] " << log_prefix << "Попытка регистрации с уже существующим ID." << std::endl;

        // БЫЛО:
        // std::string packet = MessageProtocol::build("REG_FAIL", client_id, -1, "User ID already taken");
        // ProtocolUtils::send_packet(socket, packet);

        // СТАЛО:
        ProtocolUtils::send_formatted_message(socket, "REG_FAIL", client_id, -1, "User ID already taken");
        return false;
    }

    // 2. Получаем пароль от клиента
    auto password_msg_opt = ProtocolUtils::receive_and_parse_message(socket);
    if (!password_msg_opt) {
        logger_ref.write_log(log_location, log_prefix + "Failure - Client disconnected before sending password.");
        return false;
    }
    if (password_msg_opt->header != "PASSWORD") {
         logger_ref.write_log(log_location, log_prefix + "Failure - Expected PASSWORD header, but got " + password_msg_opt->header);
         ProtocolUtils::send_formatted_message(socket, "REG_FAIL", client_id, -1, "Protocol error: expected PASSWORD");
         return false;
    }
    std::string password = password_msg_opt->message;

    // 3. Проверяем сложность пароля
    if (password.length() < 8) {
        // Здесь уже использовалась правильная функция
        ProtocolUtils::send_formatted_message(socket, "REG_FAIL", client_id, -1, "Password is too short (min 8 chars)");
        return false;
    }

    // 4. Хешируем пароль
    std::string hashed_password = CryptoUtils::generate_hash(password);

    // 5. Вставляем нового пользователя в БД
    if (db_ref.insertUser(client_id, hashed_password, client_ip)) {
        logger_ref.write_log(log_location, log_prefix + "Success - User registered successfully.");
        std::cout << "[INFO] " << log_prefix << "Пользователь успешно зарегистрирован." << std::endl;
        
        // БЫЛО:
        // std::string packet = MessageProtocol::build("REG_OK", client_id, -1, "Registration successful");
        // ProtocolUtils::send_packet(socket, packet);
        
        // СТАЛО:
        ProtocolUtils::send_formatted_message(socket, "REG_OK", client_id, -1, "Registration successful");
        return true;
    } else {
        logger_ref.write_log(log_location, log_prefix + "Failure - Database error during user insertion.");
        
        // БЫЛО:
        // std::string packet = MessageProtocol::build("REG_FAIL", client_id, -1, "Internal server error");
        // ProtocolUtils::send_packet(socket, packet);

        // СТАЛО:
        ProtocolUtils::send_formatted_message(socket, "REG_FAIL", client_id, -1, "Internal server error");
        return false;
    }
}


// --- Вспомогательная функция для удаления nonce ---
void AuthService::removeChallenge(int socket) {
    std::lock_guard<std::mutex> lock(challenges_mutex);
    active_challenges.erase(socket);
}


================================================================================
// Файл: Auth_reg/auth_service.h
================================================================================

// Auth_reg/auth_service.h
#pragma once

#include <string>
#include <map>
#include <mutex>

// Подключаем ваши классы
#include "../Base/database.h" // Класс для работы с БД
#include "../Logger/logger.h" // Класс для логирования

class AuthService {
public:
    // ... (конструктор и другие методы без изменений) ...
    AuthService(base& db, logger& logger_instance, const std::string& log_path);

    /**
     * @brief Проводит аутентификацию клиента.
     * @details Сначала вызывает selectUserByName для загрузки данных в объект БД,
     *          а затем использует getHashedPassword для их получения.
     */
    bool authenticateClient(int socket, const std::string& client_id);

    // ... (метод registerClient без изменений в сигнатуре) ...
    bool registerClient(int socket, const std::string& client_id, const std::string& client_ip);

private:
    base& db_ref; // Используем ваше имя класса 'base'
    logger& logger_ref;
    const std::string log_location; // Путь к файлу логов

    std::map<int, std::string> active_challenges;
    std::mutex challenges_mutex;

    void removeChallenge(int socket);
};

================================================================================
// Файл: Logger/logger.cpp
================================================================================

#include "logger.h"
int logger::write_log( std::string log_loc,  std::string message) {
    // Проверяем, существует ли лог-файл по указанному пути
    if (!boost::filesystem::exists(log_loc)) {
        std::cerr << "Такого лог файла не существует: " << log_loc << std::endl;
        throw critical_error("Не удалось открыть лог файл");
    }

    // Синхронизируем доступ к логированию
    std::lock_guard<std::mutex> lock(mtx);

    // Открываем файл для дозаписи внутри критической секции
    std::ofstream log_file(log_loc, std::ios::app | std::ios::out);
    if (!log_file.is_open()) {
        std::cerr << "Не удалось открыть лог файл для записи: " << log_loc << std::endl;
        throw critical_error("Не удалось открыть лог файл");
    }

    // Получаем текущее время и форматируем его
    auto now = std::chrono::system_clock::now();
    std::time_t t = std::chrono::system_clock::to_time_t(now);
    std::string time_str = std::ctime(&t);
    if (!time_str.empty() && time_str.back() == '\n') {
        time_str.pop_back();
    }

    // Записываем время и сообщение в лог-файл
    log_file << time_str << " / " << message << '\n';
    log_file.flush();  // сброс буфера
    // Файл автоматически закроется по выходу из scope

    return 0;
}

================================================================================
// Файл: Logger/logger.h
================================================================================

#pragma once
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <chrono>
#include <cstring>
#include "../Error/error.h"
#include <mutex>
#include <boost/filesystem.hpp>
class logger{
    public:
    std::ofstream log;
    std::mutex mtx;
    int write_log(std::string log_loc,std::string message);
};

================================================================================
// Файл: Protocol/protocol.cpp
================================================================================

#include "protocol.h"
#include <random>
#include <sstream>

std::string MessageProtocol::build(const std::string& header,
                                   const std::string& clientID,
                                   int messageID,
                                   const std::string& messageBody) {
    return header + "|clientID:" + clientID +
           "|messageID:" + std::to_string(messageID) +
           "|message:" + messageBody+"\n";
}
MessageProtocol::ParsedMessage MessageProtocol::parse(const std::string& raw) {
    std::mutex mtx;
    mtx.lock();
    ParsedMessage result;
    size_t pos = 0;
    size_t next = raw.find('|');

    // Header
    if (next == std::string::npos)
        return result; // bad format
    result.header = raw.substr(0, next);
    pos = next + 1;

    // Fields
    while ((next = raw.find('|', pos)) != std::string::npos) {
        std::string part = raw.substr(pos, next - pos);
        if (part.rfind("clientID:", 0) == 0) {
            result.clientID = part.substr(9);
        } else if (part.rfind("messageID:", 0) == 0) {
            try {
                result.messageID = std::stoi(part.substr(10));
            } catch (...) {
                result.messageID = -1;
            }
        }
        pos = next + 1;
    }

    // Last part (message)
    std::string last = raw.substr(pos);
    if (last.rfind("message:", 0) == 0) {
        result.message = last.substr(8);
        result.message.pop_back();
    }
    mtx.unlock();
    return result;
}

int MessageProtocol::generateMessageID() {
    static std::mt19937 gen(std::random_device{}());
    static std::uniform_int_distribution<> dist(1, 32);
    return dist(gen);
}


================================================================================
// Файл: Protocol/protocol.h
================================================================================

#pragma once
#include <string>
#include <mutex>
class MessageProtocol {
public:
    struct ParsedMessage {
        std::string header;
        std::string clientID;
        int messageID = -1;
        std::string message;
    };

    static std::string build(const std::string& header,
                             const std::string& clientID,
                             int messageID,
                             const std::string& messageBody);

    static ParsedMessage parse(const std::string& raw);
    static int generateMessageID();
};


================================================================================
// Файл: Rsa/rsa_crypto.cpp
================================================================================

#include "rsa_crypto.h"

// Зависимости для реализации
#define OPENSSL_API_COMPAT 0x10100000L
#include <openssl/bn.h>
#include <openssl/evp.h>

#include <stdexcept>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <fstream>
#include <random>

// --- Внутренние вспомогательные функции (скрыты от пользователя) ---
namespace {

// Преобразует BIGNUM (из OpenSSL) в наш BigInt
BigInt bignumToBigInt(const BIGNUM* bn) {
    char* hex_str = BN_bn2hex(bn);
    if (!hex_str) throw std::runtime_error("BN_bn2hex failed");

    std::string hex(hex_str);
    OPENSSL_free(hex_str);

    BigInt target;
    target.limbs.clear();
    if (hex.empty() || hex == "0") {
        return BigInt(0);
    }
    
    if (hex.size() % 16 != 0) {
        hex.insert(0, 16 - (hex.size() % 16), '0');
    }

    for (size_t i = 0; i < hex.size(); i += 16) {
        std::string part = hex.substr(i, 16);
        target.limbs.insert(target.limbs.begin(), std::stoull(part, nullptr, 16));
    }
    target.normalize();
    return target;
}

// Преобразует наш BigInt в BIGNUM (из OpenSSL)
// Важно: вызывающий код должен освободить память с помощью BN_free()
BIGNUM* bigIntToBignum(const BigInt& bi) {
    BIGNUM* bn = nullptr;
    std::string hex = bi.toHexString();
    BN_hex2bn(&bn, hex.c_str());
    return bn;
}

// Проверка на простоту с помощью OpenSSL
bool isPrime(const BigInt& candidate, int rounds = 64) {
    BIGNUM* bn = bigIntToBignum(candidate);
    BN_CTX* ctx = BN_CTX_new();
    int result = BN_is_prime_ex(bn, rounds, ctx, nullptr);
    BN_free(bn);
    BN_CTX_free(ctx);

    if (result < 0) throw std::runtime_error("Primality test error");
    return result == 1;
}

// Генерация кандидата в простые числа
BigInt generatePrimeCandidate(size_t len) {
    if (len < 2) return BigInt(0);
    size_t limbCount = (len + 63) / 64;

    std::random_device rd;
    std::mt19937_64 gen(rd());
    std::uniform_int_distribution<uint64_t> dis;

    BigInt result;
    result.limbs.resize(limbCount, 0);
    for (size_t i = 0; i < limbCount; i++) {
        result.limbs[i] = dis(gen);
    }
    
    // Устанавливаем старший бит, чтобы число имело нужную длину
    result.limbs.back() |= (1ULL << ((len - 1) % 64));
    // Устанавливаем младший бит, чтобы число было нечетным
    result.limbs[0] |= 1ULL;

    result.normalize();
    return result;
}

// Генерация простого числа
BigInt generatePrime(size_t bitLength, int rounds) {
    while (true) {
        BigInt candidate = generatePrimeCandidate(bitLength);
        if (isPrime(candidate, rounds)) {
            return candidate;
        }
    }
}

} // конец анонимного пространства имен

// --- Реализация методов BigInt ---

BigInt::BigInt() : limbs{0} {}
BigInt::BigInt(uint64_t value) {
    if (value == 0) limbs.push_back(0);
    else limbs.push_back(value);
}

void BigInt::normalize() {
    while (limbs.size() > 1 && limbs.back() == 0) {
        limbs.pop_back();
    }
}

bool BigInt::isZero() const {
    return limbs.size() == 1 && limbs[0] == 0;
}

std::string BigInt::toHexString() const {
    if (isZero()) return "0";
    std::ostringstream oss;
    oss << std::hex << std::uppercase;
    oss << limbs.back();
    for (int i = limbs.size() - 2; i >= 0; --i) {
        oss << std::setw(16) << std::setfill('0') << limbs[i];
    }
    return oss.str();
}

void BigInt::printHex(const std::string& label) const {
    if (!label.empty()) std::cout << label;
    std::cout << "0x" << this->toHexString() << std::dec << std::endl;
}


// --- Реализация методов RSAKeyPair ---

RSAKeyPair::RSAKeyPair(size_t bitLength) {
    std::cout << "🧪 Generating p..." << std::endl;
    p = generatePrime(bitLength / 2, 64);
    std::cout << "🧪 Generating q..." << std::endl;
    q = generatePrime(bitLength / 2, 64);

    BN_CTX* ctx = BN_CTX_new();
    BIGNUM* bn_p = bigIntToBignum(p);
    BIGNUM* bn_q = bigIntToBignum(q);
    
    // n = p * q
    BIGNUM* bn_n = BN_new();
    BN_mul(bn_n, bn_p, bn_q, ctx);
    n = bignumToBigInt(bn_n);

    // phi = (p-1)*(q-1)
    BIGNUM* bn_p1 = BN_dup(bn_p);
    BN_sub_word(bn_p1, 1);
    BIGNUM* bn_q1 = BN_dup(bn_q);
    BN_sub_word(bn_q1, 1);
    BIGNUM* bn_phi = BN_new();
    BN_mul(bn_phi, bn_p1, bn_q1, ctx);
    phi = bignumToBigInt(bn_phi);

    // e = 65537
    e = BigInt(65537);
    BIGNUM* bn_e = bigIntToBignum(e);

    // d = e^(-1) mod phi
    BIGNUM* bn_d = BN_mod_inverse(nullptr, bn_e, bn_phi, ctx);
    d = bignumToBigInt(bn_d);

    // Очистка
    BN_CTX_free(ctx);
    BN_free(bn_p); BN_free(bn_q); BN_free(bn_n);
    BN_free(bn_p1); BN_free(bn_q1); BN_free(bn_phi);
    BN_free(bn_e); BN_free(bn_d);
}

void RSAKeyPair::print() const {
    p.printHex("p: ");
    q.printHex("q: ");
    n.printHex("n (modulus): ");
    phi.printHex("phi: ");
    e.printHex("e (public exponent): ");
    d.printHex("d (private exponent): ");
}

// --- Реализация отдельных функций ---

void saveKeyToFile(const std::string& filename, const BigInt& key) {
    std::ofstream out(filename, std::ios::binary);
    if (!out) throw std::runtime_error("Не удалось открыть файл для записи: " + filename);
    uint64_t size = key.limbs.size();
    out.write(reinterpret_cast<const char*>(&size), sizeof(size));
    out.write(reinterpret_cast<const char*>(key.limbs.data()), size * sizeof(Limb));
}

BigInt loadKeyFromFile(const std::string& filename) {
    std::ifstream in(filename, std::ios::binary);
    if (!in) throw std::runtime_error("Не удалось открыть файл для чтения: " + filename);
    uint64_t size = 0;
    in.read(reinterpret_cast<char*>(&size), sizeof(size));
    if (!in || size == 0) throw std::runtime_error("Некорректный формат файла: " + filename);
    BigInt key;
    key.limbs.resize(size);
    in.read(reinterpret_cast<char*>(key.limbs.data()), size * sizeof(Limb));
    if (!in) throw std::runtime_error("Не удалось прочитать данные ключа из файла: " + filename);
    return key;
}

std::vector<unsigned char> sha256_hash_file(const std::string& filename) {
    std::ifstream file(filename, std::ios::binary);
    if (!file) throw std::runtime_error("Не удалось открыть файл: " + filename);

    EVP_MD_CTX* mdctx = EVP_MD_CTX_new();
    if (!mdctx) throw std::runtime_error("Ошибка создания контекста EVP");
    if (1 != EVP_DigestInit_ex(mdctx, EVP_sha256(), nullptr)) {
        EVP_MD_CTX_free(mdctx);
        throw std::runtime_error("Ошибка инициализации хеширования");
    }

    const size_t bufSize = 4096;
    std::vector<char> buffer(bufSize);
    while (file) {
        file.read(buffer.data(), bufSize);
        if (file.gcount() > 0) {
            if (1 != EVP_DigestUpdate(mdctx, buffer.data(), file.gcount())) {
                EVP_MD_CTX_free(mdctx);
                throw std::runtime_error("Ошибка обновления хеша");
            }
        }
    }

    std::vector<unsigned char> hash(EVP_MAX_MD_SIZE);
    unsigned int hash_len = 0;
    if (1 != EVP_DigestFinal_ex(mdctx, hash.data(), &hash_len)) {
        EVP_MD_CTX_free(mdctx);
        throw std::runtime_error("Ошибка финализации хеша");
    }
    hash.resize(hash_len);
    EVP_MD_CTX_free(mdctx);
    return hash;
}

BigInt rsa_mod_exp(const BigInt& base, const BigInt& exponent, const BigInt& modulus) {
    BN_CTX* ctx = BN_CTX_new();
    BIGNUM* bn_base = bigIntToBignum(base);
    BIGNUM* bn_exp = bigIntToBignum(exponent);
    BIGNUM* bn_mod = bigIntToBignum(modulus);
    BIGNUM* bn_res = BN_new();
    
    BN_mod_exp(bn_res, bn_base, bn_exp, bn_mod, ctx);
    
    BigInt result = bignumToBigInt(bn_res);

    BN_CTX_free(ctx);
    BN_free(bn_base); BN_free(bn_exp); BN_free(bn_mod); BN_free(bn_res);
    return result;
}

BigInt fromBytes(const std::vector<unsigned char>& bytes) {
    BIGNUM* bn = BN_bin2bn(bytes.data(), bytes.size(), nullptr);
    if (!bn) throw std::runtime_error("Ошибка конвертации байтов в BigInt");
    BigInt result = bignumToBigInt(bn);
    BN_free(bn);
    return result;
}
std::vector<unsigned char> hexStringToBytes(const std::string& hex) {
    // Создаем копию, чтобы не изменять оригинал, и убираем префикс "0x", если он есть
    std::string processedHex = hex;
    if (processedHex.rfind("0x", 0) == 0 || processedHex.rfind("0X", 0) == 0) {
        processedHex = processedHex.substr(2);
    }

    // Проверяем, что длина строки четная. Каждый байт кодируется двумя HEX-символами.
    if (processedHex.length() % 2 != 0) {
        throw std::invalid_argument("Шестнадцатеричная строка должна иметь четное количество символов.");
    }

    std::vector<unsigned char> bytes;
    // Резервируем память для повышения производительности
    bytes.reserve(processedHex.length() / 2);

    for (size_t i = 0; i < processedHex.length(); i += 2) {
        // Берем два символа (один байт)
        std::string byteString = processedHex.substr(i, 2);
        try {
            // Конвертируем два HEX-символа в число и добавляем в вектор
            unsigned char byte = static_cast<unsigned char>(std::stoul(byteString, nullptr, 16));
            bytes.push_back(byte);
        } catch (const std::exception& e) {
            throw std::invalid_argument("Строка содержит недопустимые шестнадцатеричные символы: '" + byteString + "'");
        }
    }

    return bytes;
}
BigInt BigInt::fromHexString(const std::string& hexString) {
    BIGNUM* bn = nullptr;
    std::string processedHex = hexString;
    // Удаляем префикс "0x" или "0X", если он есть
    if (processedHex.rfind("0x", 0) == 0 || processedHex.rfind("0X", 0) == 0) {
        processedHex = processedHex.substr(2);
    }
    
    // Преобразуем шестнадцатеричную строку в OpenSSL BIGNUM
    // BN_hex2bn возвращает 0 при ошибке, 1 при успехе.
    if (!BN_hex2bn(&bn, processedHex.c_str())) {
        if (bn) BN_free(bn); // Освобождаем, если что-то было выделено до ошибки
        throw std::runtime_error("Failed to convert hexadecimal string to BIGNUM: " + processedHex);
    }
    
    // Преобразуем OpenSSL BIGNUM в наш BigInt
    BigInt result = bignumToBigInt(bn);
    
    // Освобождаем память, выделенную OpenSSL для BIGNUM
    BN_free(bn);
    
    return result;
}

================================================================================
// Файл: Rsa/rsa_crypto.h
================================================================================

#ifndef RSA_CRYPTO_H
#define RSA_CRYPTO_H

#include <string>
#include <vector>
#include <cstdint>

// Тип для "конечностей" большого числа
using Limb = uint64_t;

/**
 * @brief Структура для представления произвольно больших целых чисел.
 */
struct BigInt
{
    std::vector<Limb> limbs; // Хранятся в little-endian (младшая часть в начале)

    // Конструкторы
    BigInt();
    BigInt(uint64_t value);

    // Методы
    void normalize(); // Удаляет ведущие нули
    bool isZero() const;
    void printHex(const std::string &label = "") const;
    std::string toHexString() const;
    static BigInt fromHexString(const std::string& hexString);
};

/**
 * @brief Структура для хранения и генерации пары ключей RSA.
 */
struct RSAKeyPair
{
    BigInt p, q, n, phi, e, d;

    /**
     * @brief Генерирует новую пару ключей RSA заданной длины.
     * @param bitLength Длина ключа в битах (например, 2048).
     */
    RSAKeyPair(size_t bitLength);

    /**
     * @brief Выводит все компоненты ключей в консоль.
     */
    void print() const;
};

// --- Отдельные функции модуля ---

/**
 * @brief Сохраняет ключ (BigInt) в бинарный файл.
 * @param filename Имя файла.
 * @param key Ключ для сохранения.
 */
void saveKeyToFile(const std::string &filename, const BigInt &key);

/**
 * @brief Загружает ключ (BigInt) из бинарного файла.
 * @param filename Имя файла.
 * @return Загруженный ключ типа BigInt.
 */
BigInt loadKeyFromFile(const std::string &filename);

/**
 * @brief Вычисляет хеш SHA-256 для указанного файла.
 * @param filename Путь к файлу.
 * @return Вектор байт, представляющий хеш.
 */
std::vector<unsigned char> sha256_hash_file(const std::string &filename);

/**
 * @brief Выполняет операцию модульного возведения в степень (основа^экспонента % модуль).
 * Это основная операция для шифрования и подписи в RSA.
 * @param base Основание.
 * @param exponent Экспонента (степень).
 * @param modulus Модуль.
 * @return Результат операции (BigInt).
 */
BigInt rsa_mod_exp(const BigInt &base, const BigInt &exponent, const BigInt &modulus);

/**
 * @brief Преобразует вектор байт (например, хеш) в BigInt.
 * @param bytes Входной вектор байт.
 * @return Объект BigInt.
 */
BigInt fromBytes(const std::vector<unsigned char> &bytes);
std::vector<unsigned char> hexStringToBytes(const std::string &hexString);
#endif // RSA_CRYPTO_H

