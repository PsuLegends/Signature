================================================================================
// Файл: main.cpp
================================================================================

// Файл: main.cpp
#include "UI/ui.h" // ВАШ класс UI
#include "App_logic/AppLogic.h"
#include "Error/error.h" 
#include "Logger/logger.h" // Нужно для создания логгера
#include <iostream>
#include <memory>

int main(int argc, char* argv[]) {
    try {
        // Шаг 1: Создаем ВАШ объект UI для парсинга аргументов.
        UI cmd_line_interface(argc, argv);

        // Шаг 2: Извлекаем из него все необходимые данные
        std::string ip = cmd_line_interface.get_serv_ip();
        uint16_t port = cmd_line_interface.get_port();
        std::string username = cmd_line_interface.get_username();
        std::string password = cmd_line_interface.get_password();
        uint operation_code = cmd_line_interface.get_op();

        // Шаг 3: Инициализируем зависимости, которые будут общими
        // Например, логгер. Предполагаем, что у вас есть способ получить путь к логам,
        // или зададим его по умолчанию.
        // !!!ВАЖНО!!!: У вас в классе UI нет метода для получения пути к логу, 
        // хотя в Logger он требуется. Давайте временно захардкодим путь.
        std::string log_file_path = "client_log.txt"; 
        // Убедитесь, что этот файл существует, иначе ваш логгер бросит исключение!
        std::shared_ptr<logger> app_logger = std::make_shared<logger>();

        // Шаг 4: Создаем главный логический контроллер
        AppLogic application(ip, port, username, password, app_logger, log_file_path);

        // Шаг 5: ВЫБИРАЕМ И ЗАПУСКАЕМ НУЖНЫЙ СЦЕНАРИЙ
        if (operation_code == 1) {
            // Аутентификация
            application.run_login_flow();
        } else if (operation_code == 0) {
            // Регистрация
            application.run_registration_flow();
        } else {
            // На всякий случай, хотя get_op уже должен был бросить исключение
            std::cerr << "Неизвестный код операции." << std::endl;
        }

    } catch (const po::error& e) {
        std::cerr << "Ошибка в аргументах запуска: " << e.what() << std::endl;
        return 1;
    } catch (const critical_error& e) {
        std::cerr << "Критическая ошибка: " << e.what() << std::endl;
        return 1;
    } catch (const std::exception& e) {
        std::cerr << "Непредвиденная ошибка: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}

================================================================================
// Файл: Protocol_utils/protocol_utils.cpp
================================================================================

// Файл: Protocol_utils/protocol_utils.cpp (НОВАЯ РЕАЛИЗАЦИЯ)

#include "protocol_utils.h"

// Необходимые системные заголовочные файлы
#include <sys/socket.h>
#include <unistd.h>
#include <vector>
#include <iostream>
#include <arpa/inet.h> // Для htonl, ntohl
#include <stdexcept>

namespace ProtocolUtils {

    // --- Приватные вспомогательные функции (они теперь основа) ---
    namespace {

        /**
         * @brief Надежно отправляет весь буфер данных в сокет.
         */
        int send_all(int socket, const char* buffer, size_t length) {
            size_t total_sent = 0;
            while (total_sent < length) {
                ssize_t sent_now = ::send(socket, buffer + total_sent, length - total_sent, MSG_NOSIGNAL);
                if (sent_now <= 0) {
                    perror("send_all failed");
                    return -1; // Ошибка или разрыв соединения
                }
                total_sent += sent_now;
            }
            return 0; // Успех
        }

        /**
         * @brief Надежно читает ровно `bytes_to_receive` байт из сокета.
         * Использует MSG_WAITALL для эффективности.
         * @return Строка с данными или пустая строка при ошибке/разрыве соединения.
         */
        std::string receive_all(int socket, size_t bytes_to_receive) {
            if (bytes_to_receive == 0) return "";
            
            std::string buffer(bytes_to_receive, '\0');
            ssize_t bytes_read = ::recv(socket, &buffer[0], bytes_to_receive, MSG_WAITALL);
            
            if (bytes_read != static_cast<ssize_t>(bytes_to_receive)) {
                // Если мы не получили ровно столько, сколько просили, это ошибка или разрыв.
                return "";
            }
            
            return buffer;
        }

    } // конец анонимного namespace

    // --- Реализация публичных функций с НОВОЙ логикой ---

    int send_formatted_message(int socket, const std::string& header, const std::string& client_id, int msg_id, const std::string& message) {
        // 1. Формируем тело сообщения (как и раньше)
        std::string body = MessageProtocol::build(header, client_id, msg_id, message);
        
        // 2. Получаем его длину и конвертируем в 4-байтовое сетевое число
        uint32_t len = body.length();
        uint32_t network_len = htonl(len); // Host-To-Network-Long
        
        // 3. Отправляем 4 байта с длиной
        if (send_all(socket, reinterpret_cast<const char*>(&network_len), sizeof(network_len)) != 0) {
            std::cerr << "[ProtocolUtils] Ошибка отправки длины сообщения." << std::endl;
            return -1;
        }

        // 4. Отправляем само тело сообщения
        if (send_all(socket, body.data(), body.size()) != 0) {
            std::cerr << "[ProtocolUtils] Ошибка отправки тела сообщения." << std::endl;
            return -1;
        }

        return 0; // Успех
    }
    

    std::optional<MessageProtocol::ParsedMessage> receive_and_parse_message(int socket) {
        // 1. Читаем ровно 4 байта, чтобы узнать длину
        uint32_t network_len = 0;
        std::string len_bytes = receive_all(socket, sizeof(network_len));
        if (len_bytes.size() != sizeof(network_len)) {
            // Соединение разорвано
            return std::nullopt;
        }
        network_len = *reinterpret_cast<const uint32_t*>(len_bytes.data());

        // 2. Конвертируем из сетевого порядка в хостовый
        uint32_t body_len = ntohl(network_len);
        
        // Проверка на адекватность размера (защита от DoS-атак с огромным размером)
        const size_t MAX_MSG_SIZE = 1024 * 1024; // 1 MB, например
        if (body_len > MAX_MSG_SIZE) {
            std::cerr << "[ProtocolUtils] Ошибка: получена слишком большая длина сообщения: " << body_len << std::endl;
            return std::nullopt;
        }

        // 3. Читаем ровно `body_len` байт тела сообщения
        std::string body = receive_all(socket, body_len);
        if (body.size() != body_len) {
            // Соединение разорвано при чтении тела
            return std::nullopt;
        }

        // 4. Парсим тело и возвращаем
        try {
            return MessageProtocol::parse(body);
        } catch (const std::exception& e) {
            std::cerr << "[ProtocolUtils] Ошибка парсинга тела сообщения: " << e.what() << std::endl;
            return std::nullopt;
        }
    }

} // namespace ProtocolUtils

================================================================================
// Файл: Protocol_utils/protocol_utils.h
================================================================================

// Файл: Protocol_utils/protocol_utils.h (остается без изменений)
#pragma once

#include <string>
#include <optional>
#include "../Protocol/protocol.h" 

namespace ProtocolUtils {

    /**
     * @brief Высокоуровневая функция для отправки сообщения по протоколу.
     * @details (Внутренняя реализация теперь использует 4 байта длины + тело).
     * @return 0 в случае успеха, -1 в случае ошибки.
     */
    int send_formatted_message(int socket, const std::string& header, const std::string& client_id, int msg_id, const std::string& message);

    /**
     * @brief Высокоуровневая функция для приема сообщения по протоколу.
     * @details (Внутренняя реализация теперь использует 4 байта длины + тело).
     * @return Распарсированная полезная нагрузка. std::nullopt при ошибке.
     */
    std::optional<MessageProtocol::ParsedMessage> receive_and_parse_message(int socket);

    // Старые send_packet/receive_packet можно оставить как приватные или удалить,
    // если они больше нигде не используются напрямую. Для чистоты лучше убрать.
}

================================================================================
// Файл: Error/error.h
================================================================================

#pragma once
#include <stdexcept>
#include <string>
/** Класс ошибок
*  Используется для отлова специфических ошибок, возникающих в ходе работы модулей
*  В конструкторе указывается строка с сообщением ошибки
*/
class critical_error:public std::runtime_error{
    public:
    /** Конструктор ошибки
    * s Сообщение об ошибке
    */
    critical_error(const std::string& s):std::runtime_error(s){}
};

================================================================================
// Файл: Service/SignatureService.cpp
================================================================================

// Файл: Service/SignatureService.cpp
#include "SignatureService.h"

// --- НЕОБХОДИМЫЕ ВКЛЮЧЕНИЯ ---
#include "../Crypto_utils/crypto_utils.h" // Теперь этот файл полностью определен
#include "../Rsa/rsa_crypto.h"
#include <stdexcept>
#include <algorithm> // для std::transform

// --- Реализация методов ---

std::string SignatureService::hash_file(const std::string& file_path) const {
    // Вызов функции из нашего полностью готового модуля
    return CryptoUtils::generate_hash_from_file(file_path);
}

void SignatureService::save_signature(const std::string& original_file_path, const std::string& signature_hex) const {
    // 1. Конвертируем HEX-строку подписи в объект BigInt
    BigInt signature_as_bigint = BigInt::fromHexString(signature_hex);
    
    // 2. Генерируем имя файла для подписи (например, document.txt -> document.txt.sig)
    std::string signature_filename = original_file_path + ".sig";
    
    // 3. Используем вашу существующую функцию для сохранения
    // `saveKeyToFile` находится в `Rsa/rsa_crypto.cpp`.
    saveKeyToFile(signature_filename, signature_as_bigint);
}

bool SignatureService::verify_signature(
    const std::string& original_file_path,
    const std::string& signature_file_path,
    const BigInt& public_n, 
    const BigInt& public_e
) const {
    try {
        // --- Шаг 1: Вычисляем хеш оригинального файла ---
        std::string original_hash_hex = this->hash_file(original_file_path);
        
        // --- Шаг 2: Загружаем подпись из файла ---
        // `loadKeyFromFile` находится в `Rsa/rsa_crypto.cpp`
        BigInt signature_as_bigint = loadKeyFromFile(signature_file_path);
        
        // --- Шаг 3: Расшифровываем подпись публичным ключом ---
        // `rsa_mod_exp` находится в `Rsa/rsa_crypto.cpp`
        BigInt decrypted_hash_bigint = rsa_mod_exp(signature_as_bigint, public_e, public_n);
        
        // --- Шаг 4: Конвертируем оба результата в HEX-строки и сравниваем ---
        std::string decrypted_hash_hex = decrypted_hash_bigint.toHexString();
        
        // Приводим обе строки к верхнему регистру для надежного сравнения
        std::transform(original_hash_hex.begin(), original_hash_hex.end(), original_hash_hex.begin(), ::toupper);
        std::transform(decrypted_hash_hex.begin(), decrypted_hash_hex.end(), decrypted_hash_hex.begin(), ::toupper);
        
        return original_hash_hex == decrypted_hash_hex;

    } catch (const std::exception& e) {
        // Перехватываем ошибки от нижних уровней (например, "файл не найден")
        // и передаем их наверх в виде одного понятного исключения.
        throw std::runtime_error("Ошибка в процессе верификации: " + std::string(e.what()));
    }
}

================================================================================
// Файл: Service/SignatureService.h
================================================================================

#pragma once
#include <string>
#include "../Rsa/rsa_crypto.h" 
class SignatureService {
public:
    std::string hash_file(const std::string& file_path) const;
    void save_signature(const std::string& original_file_path, const std::string& signature_hex) const;
    bool verify_signature(
        const std::string& original_file_path,
        const std::string& signature_file_path,
        const BigInt& public_n, 
        const BigInt& public_e
    ) const;
};

================================================================================
// Файл: Crypto_utils/crypto_utils.cpp
================================================================================

// Файл: Crypto_utils/crypto_utils.cpp
#include "crypto_utils.h"

// --- Заголовочные файлы Crypto++ ---
#include <cryptopp/sha.h>
#include <cryptopp/osrng.h> 
#include <cryptopp/filters.h>
#include <cryptopp/hex.h>
#include <cryptopp/secblock.h>
#include <cryptopp/files.h> // <-- Важный инклюд для работы с файлами
#include <stdexcept>

namespace CryptoUtils {

// --- generate_hash и generate_random_hex_string остаются без изменений ---

std::string generate_hash(const std::string& input) {
    CryptoPP::SHA256 hash_algorithm;
    std::string digest;
    CryptoPP::StringSource(input, true, 
        new CryptoPP::HashFilter(hash_algorithm,
            new CryptoPP::HexEncoder(
                new CryptoPP::StringSink(digest)
            )
        )
    );
    return digest;
}

std::string generate_random_hex_string(size_t byte_length) {
    CryptoPP::AutoSeededRandomPool prng;
    CryptoPP::SecByteBlock random_bytes(byte_length);
    prng.GenerateBlock(random_bytes, random_bytes.size());

    std::string hex_encoded_string;
    CryptoPP::StringSource(random_bytes, random_bytes.size(), true,
        new CryptoPP::HexEncoder(
            new CryptoPP::StringSink(hex_encoded_string)
        )
    );
    return hex_encoded_string;
}

// --- Новая функция (перенесенная из вашего старого client.cpp) ---

std::string generate_hash_from_file(const std::string& file_path) {
    try {
        CryptoPP::SHA256 hash;
        std::string digest;

        // Создаем конвейер: источник из файла -> хеш-фильтр -> кодировщик в HEX -> приемник-строка.
        CryptoPP::FileSource file(file_path.c_str(), true, 
            new CryptoPP::HashFilter(hash,
                new CryptoPP::HexEncoder(
                    new CryptoPP::StringSink(digest)
                )
            )
        );
        return digest;

    } catch (const CryptoPP::FileStore::OpenErr& e) {
        // Конкретная обработка ошибки "файл не найден"
        throw std::runtime_error("Ошибка при открытии файла для хеширования: " + file_path + ". " + e.what());
    } catch (const CryptoPP::Exception& e) {
        // Обработка других ошибок Crypto++
        throw std::runtime_error("Ошибка Crypto++ при хешировании файла " + file_path + ": " + e.what());
    }
}

} // namespace CryptoUtils

================================================================================
// Файл: Crypto_utils/crypto_utils.h
================================================================================

// crypto_utils.h
#pragma once
#include <string>

namespace CryptoUtils {
    // Хеширует строку с помощью SHA-256 и возвращает HEX
    std::string generate_hash(const std::string& input);

    // Генерирует крипто-стойкую случайную HEX-строку
    std::string generate_random_hex_string(size_t byte_length);
    std::string generate_hash_from_file(const std::string& file_path);
}

================================================================================
// Файл: UI/InteractiveConsole.cpp
================================================================================

// Файл: UI/InteractiveConsole.cpp
#include "InteractiveConsole.h"
#include <iostream>
#include <limits> // Для std::numeric_limits

// --- Реализация методов вывода ---

void InteractiveConsole::show_message(const std::string& msg) const {
    std::cout << "[INFO] " << msg << std::endl;
}

void InteractiveConsole::show_error(const std::string& err_msg) const {
    std::cerr << "[ОШИБКА] " << err_msg << std::endl;
}


// --- Реализация методов взаимодействия ---

void InteractiveConsole::clear_input_buffer() const {
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
}

UserMenuChoice InteractiveConsole::get_user_menu_choice() const {
    std::cout << "\n========================================" << std::endl;
    std::cout << "  Главное меню:" << std::endl;
    std::cout << "  1. Запросить подпись для файла" << std::endl;
    std::cout << "  2. Проверить подпись локально" << std::endl;
    std::cout << "  0. Выход" << std::endl;
    std::cout << "========================================" << std::endl;
    std::cout << "Ваш выбор -> ";

    int choice = -1;
    std::cin >> choice;

    // Проверка, что ввод был числом. Если нет, std::cin переходит в состояние ошибки.
    if (std::cin.fail()) {
        std::cin.clear(); // Сбрасываем флаг ошибки
        clear_input_buffer(); // Очищаем буфер от некорректного ввода
        return UserMenuChoice::UNKNOWN;
    }
    
    // Очищаем буфер после успешного чтения числа, чтобы следующий std::getline работал корректно
    clear_input_buffer(); 

    switch (choice) {
        case 1: return UserMenuChoice::REQUEST_SIGNATURE;
        case 2: return UserMenuChoice::VERIFY_LOCALLY;
        case 0: return UserMenuChoice::EXIT;
        default: return UserMenuChoice::UNKNOWN;
    }
}

std::string InteractiveConsole::ask_filepath(const std::string& prompt) const {
    std::cout << "[ВВОД] " << prompt;
    std::string file_path;
    std::getline(std::cin, file_path);
    
    // Простая валидация на пустой ввод
    if (file_path.empty()) {
        show_error("Путь к файлу не может быть пустым.");
    }
    return file_path;
}

// --- Реализация методов отображения результатов ---

void InteractiveConsole::display_signature(const std::string& signature_hex) const {
    std::cout << "[РЕЗУЛЬТАТ] Получена подпись от сервера:" << std::endl;
    std::cout << "------------------------------------------" << std::endl;
    std::cout << signature_hex << std::endl;
    std::cout << "------------------------------------------" << std::endl;
}

void InteractiveConsole::display_verification_result(bool is_valid) const {
    std::cout << "[РЕЗУЛЬТАТ ПРОВЕРКИ]" << std::endl;
    if (is_valid) {
        std::cout << "  ПОДПИСЬ ВЕРНА: Хеши совпадают." << std::endl;
    } else {
        std::cout << "  ПОДПИСЬ НЕВЕРНА: Хеши не совпадают." << std::endl;
    }
}

================================================================================
// Файл: UI/InteractiveConsole.h
================================================================================

#pragma once
#include <string>
enum class UserMenuChoice {
    REQUEST_SIGNATURE, // Запросить подпись для файла
    VERIFY_LOCALLY,    // Проверить подпись локально
    EXIT,              // Выход из приложения
    UNKNOWN            // Неверный ввод
};

class InteractiveConsole {
public:
    void show_message(const std::string& msg) const;
    void show_error(const std::string& err_msg) const;
    UserMenuChoice get_user_menu_choice() const;
    std::string ask_filepath(const std::string& prompt) const;
    void display_signature(const std::string& signature_hex) const;
    void display_verification_result(bool is_valid) const;
    
private:
    void clear_input_buffer() const;
};

================================================================================
// Файл: UI/ui.cpp
================================================================================

// Файл: UI/ui.cpp
#include "ui.h"
#include <iostream>
#include <stdexcept> // для std::invalid_argument
#include <arpa/inet.h> // для inet_pton

UI::UI(int argc, char* argv[]) : desc("Допустимые опции") {
    // 1. Определение опций, которые приложение принимает.
    // Это взято из вашего оригинального кода.
    desc.add_options()
        ("help,h", "Показать это сообщение")
        ("serv_ip,s", po::value<std::string>(), "IP-адрес сервера")
        ("port,p", po::value<uint16_t>(), "Порт сервера (1024-65535)")
        ("operation,o", po::value<uint>(), "Начальная операция: 0 (регистрация) или 1 (аутентификация)")
        ("username,u", po::value<std::string>(), "Имя пользователя")
        ("password,x", po::value<std::string>(), "Пароль пользователя (используем -x для безопасности)");

    // 2. Парсинг. Любые ошибки здесь будут брошены как po::error и пойманы в main.cpp.
    po::store(po::parse_command_line(argc, argv, desc), vm);
    po::notify(vm);

    // 3. Обработка опции --help. Это штатное завершение, а не ошибка.
    if (vm.count("help")) {
        std::cout << desc << std::endl;
        exit(0); // Завершаем программу после вывода справки
    }
    
    // 4. Проверка наличия всех обязательных параметров. Если чего-то нет - бросаем исключение.
    if (!vm.count("serv_ip") || !vm.count("port") || !vm.count("operation") || !vm.count("username") || !vm.count("password")) {
         std::cout << desc << std::endl;
        throw critical_error("Не все обязательные параметры были указаны. Используйте --help для справки.");
    }
}

std::string UI::get_serv_ip() const {
    const std::string ip_str = vm["serv_ip"].as<std::string>();
    
    // Проверяем, что IP-адрес имеет корректный формат IPv4
    struct sockaddr_in sa;
    if (inet_pton(AF_INET, ip_str.c_str(), &(sa.sin_addr)) != 1) {
        throw critical_error("Указанный IP-адрес '" + ip_str + "' не является корректным IPv4 адресом.");
    }
    return ip_str;
}

uint16_t UI::get_port() const {
    const uint16_t port = vm["port"].as<uint16_t>();
    if (port < 1024 || port > 65535) {
        throw critical_error("Порт " + std::to_string(port) + " находится вне допустимого диапазона [1024-65535].");
    }
    return port;
}

std::string UI::get_username() const {
    // Проверять vm.count() здесь уже не нужно, так как конструктор это сделал.
    return vm["username"].as<std::string>();
}

std::string UI::get_password() const {
    return vm["password"].as<std::string>();
}

uint UI::get_op() const {
    const uint op_code = vm["operation"].as<uint>();
    if (op_code != 0 && op_code != 1) {
        throw critical_error("Код операции должен быть 0 (регистрация) или 1 (аутентификация), но получен: " + std::to_string(op_code));
    }
    return op_code;
}

================================================================================
// Файл: UI/ui.h
================================================================================

#pragma once
#include <boost/program_options.hpp>
#include <string>
#include <vector>
#include <cstdint>
#include "../Error/error.h"
namespace po = boost::program_options;
class UI {
public:
    UI(int argc, char* argv[]);
    uint16_t get_port() const;
    std::string get_serv_ip() const;
    std::string get_username() const;
    std::string get_password() const;
    uint get_op() const;

private:
    po::options_description desc;
    po::variables_map vm;
};

================================================================================
// Файл: Logger/logger.cpp
================================================================================

#include "logger.h"
int logger::write_log( std::string log_loc,  std::string message) {
    // Проверяем, существует ли лог-файл по указанному пути
    if (!boost::filesystem::exists(log_loc)) {
        std::cerr << "Такого лог файла не существует: " << log_loc << std::endl;
        throw critical_error("Не удалось открыть лог файл");
    }

    // Синхронизируем доступ к логированию
    std::lock_guard<std::mutex> lock(mtx);

    // Открываем файл для дозаписи внутри критической секции
    std::ofstream log_file(log_loc, std::ios::app | std::ios::out);
    if (!log_file.is_open()) {
        std::cerr << "Не удалось открыть лог файл для записи: " << log_loc << std::endl;
        throw critical_error("Не удалось открыть лог файл");
    }

    // Получаем текущее время и форматируем его
    auto now = std::chrono::system_clock::now();
    std::time_t t = std::chrono::system_clock::to_time_t(now);
    std::string time_str = std::ctime(&t);
    if (!time_str.empty() && time_str.back() == '\n') {
        time_str.pop_back();
    }

    // Записываем время и сообщение в лог-файл
    log_file << time_str << " / " << message << '\n';
    log_file.flush();  // сброс буфера
    // Файл автоматически закроется по выходу из scope

    return 0;
}

================================================================================
// Файл: Logger/logger.h
================================================================================

#pragma once
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <chrono>
#include <cstring>
#include "../Error/error.h"
#include <mutex>
#include <boost/filesystem.hpp>
class logger{
    public:
    std::ofstream log;
    std::mutex mtx;
    int write_log(std::string log_loc,std::string message);
};

================================================================================
// Файл: Protocol/protocol.cpp
================================================================================

#include "protocol.h"
#include <random>
#include <sstream>

std::string MessageProtocol::build(const std::string& header,
                                   const std::string& clientID,
                                   int messageID,
                                   const std::string& messageBody) {
    return header + "|clientID:" + clientID +
           "|messageID:" + std::to_string(messageID) +
           "|message:" + messageBody+"\n";
}
MessageProtocol::ParsedMessage MessageProtocol::parse(const std::string& raw) {
    std::mutex mtx;
    mtx.lock();
    ParsedMessage result;
    size_t pos = 0;
    size_t next = raw.find('|');

    // Header
    if (next == std::string::npos)
        return result; // bad format
    result.header = raw.substr(0, next);
    pos = next + 1;

    // Fields
    while ((next = raw.find('|', pos)) != std::string::npos) {
        std::string part = raw.substr(pos, next - pos);
        if (part.rfind("clientID:", 0) == 0) {
            result.clientID = part.substr(9);
        } else if (part.rfind("messageID:", 0) == 0) {
            try {
                result.messageID = std::stoi(part.substr(10));
            } catch (...) {
                result.messageID = -1;
            }
        }
        pos = next + 1;
    }

    // Last part (message)
    std::string last = raw.substr(pos);
    if (last.rfind("message:", 0) == 0) {
        result.message = last.substr(8);
        result.message.pop_back();
    }
    mtx.unlock();
    return result;
}

int MessageProtocol::generateMessageID() {
    static std::mt19937 gen(std::random_device{}());
    static std::uniform_int_distribution<> dist(1, 32);
    return dist(gen);
}


================================================================================
// Файл: Protocol/protocol.h
================================================================================

#pragma once
#include <string>
#include <mutex>
class MessageProtocol {
public:
    struct ParsedMessage {
        std::string header;
        std::string clientID;
        int messageID = -1;
        std::string message;
    };

    static std::string build(const std::string& header,
                             const std::string& clientID,
                             int messageID,
                             const std::string& messageBody);

    static ParsedMessage parse(const std::string& raw);
    static int generateMessageID();
};


================================================================================
// Файл: Rsa/rsa_crypto.cpp
================================================================================

#include "rsa_crypto.h"

// Зависимости для реализации
#define OPENSSL_API_COMPAT 0x10100000L
#include <openssl/bn.h>
#include <openssl/evp.h>

#include <stdexcept>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <fstream>
#include <random>

// --- Внутренние вспомогательные функции (скрыты от пользователя) ---
namespace {

// Преобразует BIGNUM (из OpenSSL) в наш BigInt
BigInt bignumToBigInt(const BIGNUM* bn) {
    char* hex_str = BN_bn2hex(bn);
    if (!hex_str) throw std::runtime_error("BN_bn2hex failed");

    std::string hex(hex_str);
    OPENSSL_free(hex_str);

    BigInt target;
    target.limbs.clear();
    if (hex.empty() || hex == "0") {
        return BigInt(0);
    }
    
    if (hex.size() % 16 != 0) {
        hex.insert(0, 16 - (hex.size() % 16), '0');
    }

    for (size_t i = 0; i < hex.size(); i += 16) {
        std::string part = hex.substr(i, 16);
        target.limbs.insert(target.limbs.begin(), std::stoull(part, nullptr, 16));
    }
    target.normalize();
    return target;
}

// Преобразует наш BigInt в BIGNUM (из OpenSSL)
// Важно: вызывающий код должен освободить память с помощью BN_free()
BIGNUM* bigIntToBignum(const BigInt& bi) {
    BIGNUM* bn = nullptr;
    std::string hex = bi.toHexString();
    BN_hex2bn(&bn, hex.c_str());
    return bn;
}

// Проверка на простоту с помощью OpenSSL
bool isPrime(const BigInt& candidate, int rounds = 64) {
    BIGNUM* bn = bigIntToBignum(candidate);
    BN_CTX* ctx = BN_CTX_new();
    int result = BN_is_prime_ex(bn, rounds, ctx, nullptr);
    BN_free(bn);
    BN_CTX_free(ctx);

    if (result < 0) throw std::runtime_error("Primality test error");
    return result == 1;
}

// Генерация кандидата в простые числа
BigInt generatePrimeCandidate(size_t len) {
    if (len < 2) return BigInt(0);
    size_t limbCount = (len + 63) / 64;

    std::random_device rd;
    std::mt19937_64 gen(rd());
    std::uniform_int_distribution<uint64_t> dis;

    BigInt result;
    result.limbs.resize(limbCount, 0);
    for (size_t i = 0; i < limbCount; i++) {
        result.limbs[i] = dis(gen);
    }
    
    // Устанавливаем старший бит, чтобы число имело нужную длину
    result.limbs.back() |= (1ULL << ((len - 1) % 64));
    // Устанавливаем младший бит, чтобы число было нечетным
    result.limbs[0] |= 1ULL;

    result.normalize();
    return result;
}

// Генерация простого числа
BigInt generatePrime(size_t bitLength, int rounds) {
    while (true) {
        BigInt candidate = generatePrimeCandidate(bitLength);
        if (isPrime(candidate, rounds)) {
            return candidate;
        }
    }
}

} // конец анонимного пространства имен

// --- Реализация методов BigInt ---

BigInt::BigInt() : limbs{0} {}
BigInt::BigInt(uint64_t value) {
    if (value == 0) limbs.push_back(0);
    else limbs.push_back(value);
}

void BigInt::normalize() {
    while (limbs.size() > 1 && limbs.back() == 0) {
        limbs.pop_back();
    }
}

bool BigInt::isZero() const {
    return limbs.size() == 1 && limbs[0] == 0;
}

std::string BigInt::toHexString() const {
    if (isZero()) return "0";
    std::ostringstream oss;
    oss << std::hex << std::uppercase;
    oss << limbs.back();
    for (int i = limbs.size() - 2; i >= 0; --i) {
        oss << std::setw(16) << std::setfill('0') << limbs[i];
    }
    return oss.str();
}

void BigInt::printHex(const std::string& label) const {
    if (!label.empty()) std::cout << label;
    std::cout << "0x" << this->toHexString() << std::dec << std::endl;
}


// --- Реализация методов RSAKeyPair ---

RSAKeyPair::RSAKeyPair(size_t bitLength) {
    std::cout << "🧪 Generating p..." << std::endl;
    p = generatePrime(bitLength / 2, 64);
    std::cout << "🧪 Generating q..." << std::endl;
    q = generatePrime(bitLength / 2, 64);

    BN_CTX* ctx = BN_CTX_new();
    BIGNUM* bn_p = bigIntToBignum(p);
    BIGNUM* bn_q = bigIntToBignum(q);
    
    // n = p * q
    BIGNUM* bn_n = BN_new();
    BN_mul(bn_n, bn_p, bn_q, ctx);
    n = bignumToBigInt(bn_n);

    // phi = (p-1)*(q-1)
    BIGNUM* bn_p1 = BN_dup(bn_p);
    BN_sub_word(bn_p1, 1);
    BIGNUM* bn_q1 = BN_dup(bn_q);
    BN_sub_word(bn_q1, 1);
    BIGNUM* bn_phi = BN_new();
    BN_mul(bn_phi, bn_p1, bn_q1, ctx);
    phi = bignumToBigInt(bn_phi);

    // e = 65537
    e = BigInt(65537);
    BIGNUM* bn_e = bigIntToBignum(e);

    // d = e^(-1) mod phi
    BIGNUM* bn_d = BN_mod_inverse(nullptr, bn_e, bn_phi, ctx);
    d = bignumToBigInt(bn_d);

    // Очистка
    BN_CTX_free(ctx);
    BN_free(bn_p); BN_free(bn_q); BN_free(bn_n);
    BN_free(bn_p1); BN_free(bn_q1); BN_free(bn_phi);
    BN_free(bn_e); BN_free(bn_d);
}

void RSAKeyPair::print() const {
    p.printHex("p: ");
    q.printHex("q: ");
    n.printHex("n (modulus): ");
    phi.printHex("phi: ");
    e.printHex("e (public exponent): ");
    d.printHex("d (private exponent): ");
}

// --- Реализация отдельных функций ---

void saveKeyToFile(const std::string& filename, const BigInt& key) {
    std::ofstream out(filename, std::ios::binary);
    if (!out) throw std::runtime_error("Не удалось открыть файл для записи: " + filename);
    uint64_t size = key.limbs.size();
    out.write(reinterpret_cast<const char*>(&size), sizeof(size));
    out.write(reinterpret_cast<const char*>(key.limbs.data()), size * sizeof(Limb));
}

BigInt loadKeyFromFile(const std::string& filename) {
    std::ifstream in(filename, std::ios::binary);
    if (!in) throw std::runtime_error("Не удалось открыть файл для чтения: " + filename);
    uint64_t size = 0;
    in.read(reinterpret_cast<char*>(&size), sizeof(size));
    if (!in || size == 0) throw std::runtime_error("Некорректный формат файла: " + filename);
    BigInt key;
    key.limbs.resize(size);
    in.read(reinterpret_cast<char*>(key.limbs.data()), size * sizeof(Limb));
    if (!in) throw std::runtime_error("Не удалось прочитать данные ключа из файла: " + filename);
    return key;
}

std::vector<unsigned char> sha256_hash_file(const std::string& filename) {
    std::ifstream file(filename, std::ios::binary);
    if (!file) throw std::runtime_error("Не удалось открыть файл: " + filename);

    EVP_MD_CTX* mdctx = EVP_MD_CTX_new();
    if (!mdctx) throw std::runtime_error("Ошибка создания контекста EVP");
    if (1 != EVP_DigestInit_ex(mdctx, EVP_sha256(), nullptr)) {
        EVP_MD_CTX_free(mdctx);
        throw std::runtime_error("Ошибка инициализации хеширования");
    }

    const size_t bufSize = 4096;
    std::vector<char> buffer(bufSize);
    while (file) {
        file.read(buffer.data(), bufSize);
        if (file.gcount() > 0) {
            if (1 != EVP_DigestUpdate(mdctx, buffer.data(), file.gcount())) {
                EVP_MD_CTX_free(mdctx);
                throw std::runtime_error("Ошибка обновления хеша");
            }
        }
    }

    std::vector<unsigned char> hash(EVP_MAX_MD_SIZE);
    unsigned int hash_len = 0;
    if (1 != EVP_DigestFinal_ex(mdctx, hash.data(), &hash_len)) {
        EVP_MD_CTX_free(mdctx);
        throw std::runtime_error("Ошибка финализации хеша");
    }
    hash.resize(hash_len);
    EVP_MD_CTX_free(mdctx);
    return hash;
}

BigInt rsa_mod_exp(const BigInt& base, const BigInt& exponent, const BigInt& modulus) {
    BN_CTX* ctx = BN_CTX_new();
    BIGNUM* bn_base = bigIntToBignum(base);
    BIGNUM* bn_exp = bigIntToBignum(exponent);
    BIGNUM* bn_mod = bigIntToBignum(modulus);
    BIGNUM* bn_res = BN_new();
    
    BN_mod_exp(bn_res, bn_base, bn_exp, bn_mod, ctx);
    
    BigInt result = bignumToBigInt(bn_res);

    BN_CTX_free(ctx);
    BN_free(bn_base); BN_free(bn_exp); BN_free(bn_mod); BN_free(bn_res);
    return result;
}

BigInt fromBytes(const std::vector<unsigned char>& bytes) {
    BIGNUM* bn = BN_bin2bn(bytes.data(), bytes.size(), nullptr);
    if (!bn) throw std::runtime_error("Ошибка конвертации байтов в BigInt");
    BigInt result = bignumToBigInt(bn);
    BN_free(bn);
    return result;
}
std::vector<unsigned char> hexStringToBytes(const std::string& hex) {
    // Создаем копию, чтобы не изменять оригинал, и убираем префикс "0x", если он есть
    std::string processedHex = hex;
    if (processedHex.rfind("0x", 0) == 0 || processedHex.rfind("0X", 0) == 0) {
        processedHex = processedHex.substr(2);
    }

    // Проверяем, что длина строки четная. Каждый байт кодируется двумя HEX-символами.
    if (processedHex.length() % 2 != 0) {
        throw std::invalid_argument("Шестнадцатеричная строка должна иметь четное количество символов.");
    }

    std::vector<unsigned char> bytes;
    // Резервируем память для повышения производительности
    bytes.reserve(processedHex.length() / 2);

    for (size_t i = 0; i < processedHex.length(); i += 2) {
        // Берем два символа (один байт)
        std::string byteString = processedHex.substr(i, 2);
        try {
            // Конвертируем два HEX-символа в число и добавляем в вектор
            unsigned char byte = static_cast<unsigned char>(std::stoul(byteString, nullptr, 16));
            bytes.push_back(byte);
        } catch (const std::exception& e) {
            throw std::invalid_argument("Строка содержит недопустимые шестнадцатеричные символы: '" + byteString + "'");
        }
    }

    return bytes;
}
BigInt BigInt::fromHexString(const std::string& hexString) {
    BIGNUM* bn = nullptr;
    std::string processedHex = hexString;
    // Удаляем префикс "0x" или "0X", если он есть
    if (processedHex.rfind("0x", 0) == 0 || processedHex.rfind("0X", 0) == 0) {
        processedHex = processedHex.substr(2);
    }
    
    // Преобразуем шестнадцатеричную строку в OpenSSL BIGNUM
    // BN_hex2bn возвращает 0 при ошибке, 1 при успехе.
    if (!BN_hex2bn(&bn, processedHex.c_str())) {
        if (bn) BN_free(bn); // Освобождаем, если что-то было выделено до ошибки
        throw std::runtime_error("Failed to convert hexadecimal string to BIGNUM: " + processedHex);
    }
    
    // Преобразуем OpenSSL BIGNUM в наш BigInt
    BigInt result = bignumToBigInt(bn);
    
    // Освобождаем память, выделенную OpenSSL для BIGNUM
    BN_free(bn);
    
    return result;
}

================================================================================
// Файл: Rsa/rsa_crypto.h
================================================================================

#ifndef RSA_CRYPTO_H
#define RSA_CRYPTO_H

#include <string>
#include <vector>
#include <cstdint>

// Тип для "конечностей" большого числа
using Limb = uint64_t;

/**
 * @brief Структура для представления произвольно больших целых чисел.
 */
struct BigInt
{
    std::vector<Limb> limbs; // Хранятся в little-endian (младшая часть в начале)

    // Конструкторы
    BigInt();
    BigInt(uint64_t value);

    // Методы
    void normalize(); // Удаляет ведущие нули
    bool isZero() const;
    void printHex(const std::string &label = "") const;
    std::string toHexString() const;
    static BigInt fromHexString(const std::string& hexString);
};

/**
 * @brief Структура для хранения и генерации пары ключей RSA.
 */
struct RSAKeyPair
{
    BigInt p, q, n, phi, e, d;

    /**
     * @brief Генерирует новую пару ключей RSA заданной длины.
     * @param bitLength Длина ключа в битах (например, 2048).
     */
    RSAKeyPair(size_t bitLength);

    /**
     * @brief Выводит все компоненты ключей в консоль.
     */
    void print() const;
};

// --- Отдельные функции модуля ---

/**
 * @brief Сохраняет ключ (BigInt) в бинарный файл.
 * @param filename Имя файла.
 * @param key Ключ для сохранения.
 */
void saveKeyToFile(const std::string &filename, const BigInt &key);

/**
 * @brief Загружает ключ (BigInt) из бинарного файла.
 * @param filename Имя файла.
 * @return Загруженный ключ типа BigInt.
 */
BigInt loadKeyFromFile(const std::string &filename);

/**
 * @brief Вычисляет хеш SHA-256 для указанного файла.
 * @param filename Путь к файлу.
 * @return Вектор байт, представляющий хеш.
 */
std::vector<unsigned char> sha256_hash_file(const std::string &filename);

/**
 * @brief Выполняет операцию модульного возведения в степень (основа^экспонента % модуль).
 * Это основная операция для шифрования и подписи в RSA.
 * @param base Основание.
 * @param exponent Экспонента (степень).
 * @param modulus Модуль.
 * @return Результат операции (BigInt).
 */
BigInt rsa_mod_exp(const BigInt &base, const BigInt &exponent, const BigInt &modulus);

/**
 * @brief Преобразует вектор байт (например, хеш) в BigInt.
 * @param bytes Входной вектор байт.
 * @return Объект BigInt.
 */
BigInt fromBytes(const std::vector<unsigned char> &bytes);
std::vector<unsigned char> hexStringToBytes(const std::string &hexString);
#endif // RSA_CRYPTO_H

================================================================================
// Файл: App_logic/AppLogic.cpp
================================================================================

// Файл: App_logic/AppLogic.cpp
#include "AppLogic.h"

// Прямая зависимость от утилит протокола и криптографии
#include "../Protocol_utils/protocol_utils.h"
#include "../Crypto_utils/crypto_utils.h"

// Системные инклюды для работы с сокетами
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdexcept>
#include <cerrno>  // для errno
#include <cstring> // для strerror

// --- Конструктор и Деструктор ---

AppLogic::AppLogic(
    const std::string& ip, uint16_t port, const std::string& username, 
    const std::string& password, std::shared_ptr<logger> logger_instance,
    const std::string& log_path
) :
    m_server_ip(ip),
    m_server_port(port),
    m_user_name(username),
    m_user_password(password),
    m_logger(logger_instance),
    m_log_path(log_path)
{
    if (!m_logger) {
        throw std::invalid_argument("Logger instance in AppLogic cannot be null.");
    }
}

AppLogic::~AppLogic() {
    disconnect();
}

// --- ОСНОВНЫЕ СЦЕНАРИИ ---

void AppLogic::run_login_flow() {
    m_logger->write_log(m_log_path, "[AppLogic] Запуск клиента для '" + m_user_name + "' в режиме АУТЕНТИФИКАЦИИ.");
    
    if (!connect_to_server()) {
        m_console.show_error("Не удалось подключиться к серверу.");
        return;
    }
    
    if (perform_authentication()) {
        main_loop();
    } else {
        m_console.show_error("Аутентификация не удалась. Отключение.");
    }

    disconnect();
    m_console.show_message("Работа клиента завершена.");
    m_logger->write_log(m_log_path, "[AppLogic] Клиент штатно завершил работу.");
}

void AppLogic::run_registration_flow() {
    m_logger->write_log(m_log_path, "[AppLogic] Запуск клиента для '" + m_user_name + "' в режиме РЕГИСТРАЦИИ.");

    if (!connect_to_server()) {
        m_console.show_error("Не удалось подключиться к серверу.");
        return;
    }
    
    m_logger->write_log(m_log_path, "[AppLogic] Начало процесса регистрации.");
    if (!send_message({ "REGISTER", m_user_name, -1, "" })) {
        disconnect(); return;
    }
    
    if (!send_message({ "PASSWORD", m_user_name, -1, m_user_password })) {
        disconnect(); return;
    }
    
    auto reg_result = receive_message();
    if (reg_result && reg_result->header == "REG_OK") {
        m_logger->write_log(m_log_path, "[AppLogic] Регистрация успешна.");
        m_console.show_message("Регистрация пользователя '" + m_user_name + "' прошла успешно!");
    } else {
        std::string error_details = reg_result ? reg_result->message : "сервер не отвечает";
        m_logger->write_log(m_log_path, "[AppLogic] Регистрация провалена: " + error_details);
        m_console.show_error("Регистрация не удалась: " + error_details);
    }
    
    disconnect();
}


// --- Приватные методы ---

bool AppLogic::is_connected() const {
    return m_socket != -1;
}

bool AppLogic::connect_to_server() {
    m_logger->write_log(m_log_path, "[AppLogic] Попытка подключения к " + m_server_ip + ":" + std::to_string(m_server_port));
    
    m_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (m_socket < 0) { 
        m_logger->write_log(m_log_path, "[AppLogic] Ошибка создания сокета: " + std::string(strerror(errno)));
        return false;
    }

    sockaddr_in server_addr{};
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(m_server_port);
    if (inet_pton(AF_INET, m_server_ip.c_str(), &server_addr.sin_addr) <= 0) {
        m_logger->write_log(m_log_path, "[AppLogic] Ошибка: неверный IP адрес " + m_server_ip);
        disconnect();
        return false;
    }
    
    if (::connect(m_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        m_logger->write_log(m_log_path, "[AppLogic] Ошибка подключения к серверу: " + std::string(strerror(errno)));
        disconnect();
        return false;
    }
    
    auto welcome_msg = receive_message();
    if (!welcome_msg) {
        m_logger->write_log(m_log_path, "[AppLogic] Сервер не прислал приветственное сообщение.");
        return false;
    }
    
    if (welcome_msg->header == "CONN_REJECT") {
         m_logger->write_log(m_log_path, "[AppLogic] Отказ в соединении: " + welcome_msg->message);
         disconnect();
         return false;
    }
    
    if (welcome_msg->header != "CONN_ACCEPT") {
        m_logger->write_log(m_log_path, "[AppLogic] Ошибка: получено некорректное приветствие: " + welcome_msg->header);
        disconnect();
        return false;
    }
    
    m_logger->write_log(m_log_path, "[AppLogic] Соединение с сервером успешно установлено.");
    return true;
}

void AppLogic::disconnect() {
    if (is_connected()) {
        m_logger->write_log(m_log_path, "[AppLogic] Закрытие сокета.");
        ::close(m_socket);
        m_socket = -1;
    }
}

bool AppLogic::send_message(const MessageProtocol::ParsedMessage& msg) {
    if (!is_connected()) {
        m_logger->write_log(m_log_path, "[AppLogic] Ошибка отправки: нет активного соединения.");
        return false;
    }
    if (ProtocolUtils::send_formatted_message(m_socket, msg.header, msg.clientID, msg.messageID, msg.message) != 0) {
        m_logger->write_log(m_log_path, "[AppLogic] Ошибка отправки сообщения, разрыв соединения.");
        disconnect();
        return false;
    }
    return true;
}

std::optional<MessageProtocol::ParsedMessage> AppLogic::receive_message() {
    if (!is_connected()) return std::nullopt;
    auto msg = ProtocolUtils::receive_and_parse_message(m_socket);
    if (!msg) {
        m_logger->write_log(m_log_path, "[AppLogic] Соединение было разорвано во время ожидания сообщения.");
        disconnect();
    }
    return msg;
}

bool AppLogic::perform_authentication() {
    m_logger->write_log(m_log_path, "[AppLogic] Начало аутентификации.");
    
    if (!send_message({ "LOGIN", m_user_name, -1, "" })) return false;

    auto challenge_msg = receive_message();
    if (!challenge_msg || challenge_msg->header != "CHALLENGE") {
        m_logger->write_log(m_log_path, "[AppLogic] Ошибка: не получен корректный challenge от сервера.");
        return false;
    }
    
    const std::string& nonce = challenge_msg->message;
    std::string pass_hash = CryptoUtils::generate_hash(m_user_password);
    std::string response_hash = CryptoUtils::generate_hash(pass_hash + nonce);

    if (!send_message({ "CHALLENGE_RESPONSE", m_user_name, -1, response_hash })) return false;
    
    auto auth_result = receive_message();
    if (auth_result && auth_result->header == "AUTH_OK") {
        m_logger->write_log(m_log_path, "[AppLogic] Аутентификация успешна.");
        m_console.show_message("Аутентификация прошла успешно!");
        return true;
    } else {
        std::string error_details = auth_result ? auth_result->message : "сервер не отвечает";
        m_logger->write_log(m_log_path, "[AppLogic] Аутентификация провалена: " + error_details);
        return false;
    }
}

void AppLogic::main_loop() {
    while (is_connected()) {
        UserMenuChoice choice = m_console.get_user_menu_choice();
        
        if (choice == UserMenuChoice::EXIT) {
            send_message({ "LOGOUT", m_user_name, -1, "" });
            break; 
        }

        switch (choice) {
            case UserMenuChoice::REQUEST_SIGNATURE: handle_signing_request(); break;
            case UserMenuChoice::VERIFY_LOCALLY: handle_verification_request(); break;
            case UserMenuChoice::UNKNOWN:
            default:
                m_console.show_error("Неверный выбор. Пожалуйста, попробуйте снова.");
                break;
        }
    }
}

void AppLogic::handle_signing_request() {
    m_logger->write_log(m_log_path, "[AppLogic] Пользователь запросил подпись файла.");
    
    std::string file_path = m_console.ask_filepath("Введите полный путь к файлу для подписи: ");
    if (file_path.empty()) return;

    std::string hex_hash;
    try {
        hex_hash = m_signature_service.hash_file(file_path);
    } catch (const std::exception& e) {
        m_console.show_error(e.what());
        m_logger->write_log(m_log_path, "[AppLogic] Ошибка хеширования: " + std::string(e.what()));
        return;
    }
    
    // ================== ИСПРАВЛЕНИЕ ==================
    // ШАГ А: Отправляем команду, ЧТО мы хотим сделать. Тело сообщения пустое.
    m_logger->write_log(m_log_path, "[AppLogic] Отправка команды SIGN_HASH на сервер.");
    if (!send_message({ "SIGN_HASH", m_user_name, -1, "" })) {
        m_console.show_error("Не удалось отправить команду на сервер.");
        return;
    }

    // ШАГ Б: Отправляем ДАННЫЕ для этой команды. Заголовок можно сделать любым
    // информативным, например HASH_DATA, или даже оставить пустым, т.к. сервер его не проверяет.
    m_logger->write_log(m_log_path, "[AppLogic] Отправка хеша на сервер: " + hex_hash);
    if (!send_message({ "HASH_DATA", m_user_name, -1, hex_hash })) {
        m_console.show_error("Не удалось отправить хеш на сервер.");
        return;
    }
    // =================================================

    // Теперь получаем ответ (подпись)
    auto response = receive_message();
    if (response && response->header == "SIGN_SUCCESS") {
        // ... остальной код обработки подписи без изменений ...
        const std::string& signature_hex = response->message;
        m_console.display_signature(signature_hex);
        try {
            m_signature_service.save_signature(file_path, signature_hex);
            m_console.show_message("Подпись сохранена в файл: " + file_path + ".sig");
        } catch (const std::exception& e) {
            m_console.show_error(e.what());
        }
    } else {
        std::string err = response ? response->message : "сервер разорвал соединение";
        m_console.show_error("Не удалось получить подпись: " + err);
    }
}

void AppLogic::handle_verification_request() {
    m_logger->write_log(m_log_path, "[AppLogic] Пользователь запросил проверку подписи.");
    
    BigInt n, e;
    if (!request_public_key(n, e)) {
        m_console.show_error("Не удалось получить публичный ключ от сервера.");
        return;
    }
    m_console.show_message("Публичный ключ успешно получен.");
    
    std::string original_path = m_console.ask_filepath("Введите путь к ОРИГИНАЛЬНОМУ файлу: ");
    if (original_path.empty()) return;

    std::string signature_path = m_console.ask_filepath("Введите путь к файлу ПОДПИСИ (*.sig): ");
    if (signature_path.empty()) return;
    
    try {
        bool is_valid = m_signature_service.verify_signature(original_path, signature_path, n, e);
        m_console.display_verification_result(is_valid);
        m_logger->write_log(
        m_log_path, 
        std::string("[AppLogic] Проверка подписи завершена. Результат: ") + (is_valid ? "УСПЕХ" : "ПРОВАЛ")
    );
    } catch (const std::exception& e) {
        m_console.show_error(e.what());
        m_logger->write_log(m_log_path, "[AppLogic] Ошибка при верификации: " + std::string(e.what()));
    }
}

bool AppLogic::request_public_key(BigInt& out_n, BigInt& out_e) {
    m_logger->write_log(m_log_path, "[AppLogic] Запрос публичного ключа у сервера.");
    
    if (!send_message({ "GET_PUB_KEY", m_user_name, -1, "" })) return false;

    auto n_response = receive_message();
    if (!n_response || n_response->header != "PUB_KEY_N") {
        m_logger->write_log(m_log_path, "[AppLogic] Ошибка: не получена компонента N ключа.");
        return false;
    }
    auto e_response = receive_message();
    if (!e_response || e_response->header != "PUB_KEY_E") {
         m_logger->write_log(m_log_path, "[AppLogic] Ошибка: не получена компонента E ключа.");
        return false;
    }
    
    try {
        out_n = BigInt::fromHexString(n_response->message);
        out_e = BigInt::fromHexString(e_response->message);
        m_logger->write_log(m_log_path, "[AppLogic] Публичный ключ успешно получен и распарсен.");
        return true;
    } catch (const std::exception& e) {
        m_logger->write_log(m_log_path, "[AppLogic] Ошибка конвертации ключа из HEX: " + std::string(e.what()));
        return false;
    }
}

================================================================================
// Файл: App_logic/AppLogic.h
================================================================================

// Файл: App_logic/AppLogic.h
#pragma once

#include <string>
#include <memory>
#include <optional>
#include <cstdint>

// Включаем интерфейсы всех модулей, которыми будем управлять
#include "../Service/SignatureService.h"
#include "../UI/InteractiveConsole.h"
#include "../Logger/logger.h"
#include "../Rsa/rsa_crypto.h"
#include "../Protocol/protocol.h" // Для ParsedMessage

class AppLogic {
public:
    AppLogic(
        const std::string& ip,
        uint16_t port,
        const std::string& username,
        const std::string& password,
        std::shared_ptr<logger> logger_instance,
        const std::string& log_path
    );
    
    ~AppLogic();

    // Запрещаем копирование, т.к. управляем уникальным ресурсом (сокетом)
    AppLogic(const AppLogic&) = delete;
    AppLogic& operator=(const AppLogic&) = delete;

    // --- Основные сценарии запуска ---
    void run_login_flow();
    void run_registration_flow();

private:
    // --- Приватные сетевые методы ---
    bool connect_to_server();
    void disconnect();
    bool send_message(const MessageProtocol::ParsedMessage& msg);
    std::optional<MessageProtocol::ParsedMessage> receive_message();
    bool is_connected() const;

    // --- Приватные методы бизнес-логики ---
    bool perform_authentication();
    void main_loop();
    void handle_signing_request();
    void handle_verification_request();
    bool request_public_key(BigInt& out_n, BigInt& out_e);
    
    // --- Состояние и зависимости ---
    int m_socket = -1; // Теперь сокет принадлежит AppLogic

    // Данные сессии
    std::string m_server_ip;
    uint16_t m_server_port;
    std::string m_user_name;
    std::string m_user_password;
    std::string m_log_path;

    // Компоненты-исполнители
    SignatureService m_signature_service;
    InteractiveConsole m_console;
    std::shared_ptr<logger> m_logger;
};

