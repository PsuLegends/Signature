================================================================================
// –§–∞–π–ª: main.cpp
================================================================================

#include "ui.h"
#include "client.h"
#include "show_error.h"
#include "error.h"
int main(int argc, char* argv[])
{
    try{
        UI interface (argc,argv);
        client CL;
        CL.work(interface);
    }catch (po::error& e) {
        std::cout << e.what() << std::endl;
    }
    catch(client_error &e){
        std::cout<<"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: "<<e.what()<<std::endl;
    }
    return 0;
}


================================================================================
// –§–∞–π–ª: Protocol_utils/protocol_utils.cpp
================================================================================

#include "protocol_utils.h"

// –°–∏—Å—Ç–µ–º–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–æ—á–Ω—ã–µ —Ñ–∞–π–ª—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Å–æ–∫–µ—Ç–∞–º–∏
#include <sys/socket.h>
#include <unistd.h> // –î–ª—è close()
#include <vector>
#include <iostream> // –î–ª—è –≤—ã–≤–æ–¥–∞ –æ—à–∏–±–æ–∫

namespace ProtocolUtils
{

    /**
     * –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞–¥–µ–∂–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö.
     */
    int send_packet(int socket, const std::string &data)
    {
        if (socket < 0)
        {
            std::cerr << "[ERROR] [ProtocolUtils::send_packet] Invalid socket descriptor." << std::endl;
            return -1;
        }

        const char *buffer = data.data();
        size_t total_to_send = data.size();
        size_t total_sent = 0;

        // –¶–∏–∫–ª –±—É–¥–µ—Ç –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å—Å—è, –ø–æ–∫–∞ –≤—Å–µ –±–∞–π—Ç—ã –Ω–µ –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã
        while (total_sent < total_to_send)
        {
            // –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –¥–∞–Ω–Ω—ã–µ.
            // MSG_NOSIGNAL –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Å–∏–≥–Ω–∞–ª–∞ SIGPIPE, –µ—Å–ª–∏ –∫–ª–∏–µ–Ω—Ç
            // –≤–Ω–µ–∑–∞–ø–Ω–æ –∑–∞–∫—Ä—ã–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ. –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ send() –≤–µ—Ä–Ω–µ—Ç –æ—à–∏–±–∫—É.
            ssize_t bytes_sent_this_call = send(socket, buffer + total_sent, total_to_send - total_sent, MSG_NOSIGNAL);

            if (bytes_sent_this_call < 0)
            {
                // –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ —Å–æ–∫–µ—Ç–∞
                perror("[ERROR] [ProtocolUtils::send_packet] send() failed");
                return -1;
            }

            if (bytes_sent_this_call == 0)
            {
                // –≠—Ç–æ —Ä–µ–¥–∫–∞—è —Å–∏—Ç—É–∞—Ü–∏—è, –Ω–æ –º–æ–∂–µ—Ç –æ–∑–Ω–∞—á–∞—Ç—å, —á—Ç–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ.
                std::cerr << "[ERROR] [ProtocolUtils::send_packet] Connection closed by peer." << std::endl;
                return -1;
            }

            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –±–∞–π—Ç
            total_sent += bytes_sent_this_call;
        }

        return 0; // –í—Å–µ –¥–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã
    }

    /**
     * –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–µ–º–∞ –¥–∞–Ω–Ω—ã—Ö.
     */
    std::string receive_packet(int socket, size_t buffer_size)
    {
        if (socket < 0)
        {
            std::cerr << "[ERROR] [ProtocolUtils::receive_packet] Invalid socket descriptor." << std::endl;
            return "";
        }

        // –°–æ–∑–¥–∞–µ–º –±—É—Ñ–µ—Ä –¥–ª—è –ø—Ä–∏–µ–º–∞ –¥–∞–Ω–Ω—ã—Ö
        std::vector<char> buffer(buffer_size);

        // –ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ—á–∏—Ç–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ–∫–µ—Ç–∞
        ssize_t bytes_received = recv(socket, buffer.data(), buffer.size(), 0);

        if (bytes_received < 0)
        {
            // –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ —Å–æ–∫–µ—Ç–∞
            perror("[ERROR] [ProtocolUtils::receive_packet] recv() failed");
            return ""; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É –ø—Ä–∏ –æ—à–∏–±–∫–µ
        }

        if (bytes_received == 0)
        {
            // –≠—Ç–æ —à—Ç–∞—Ç–Ω–∞—è —Å–∏—Ç—É–∞—Ü–∏—è, –æ–∑–Ω–∞—á–∞—é—â–∞—è, —á—Ç–æ –∫–ª–∏–µ–Ω—Ç –∑–∞–∫—Ä—ã–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
            // —Å –µ–≥–æ —Å—Ç–æ—Ä–æ–Ω—ã (–ø–æ—Å–ª–∞–ª FIN).
            std::cout << "[INFO] [ProtocolUtils::receive_packet] Connection closed by peer (socket " << socket << ")." << std::endl;
            return ""; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É, —Å–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É—è –æ –∑–∞–∫—Ä—ã—Ç–∏–∏
        }

        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç—Ä–æ–∫—É, —Å–æ–∑–¥–∞–Ω–Ω—É—é –∏–∑ –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        return std::string(buffer.data(), bytes_received);
    }
    int send_formatted_message(int socket, const std::string &header, const std::string &client_id, int msg_id, const std::string &message)
    {
        // 1. –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –ø–∞–∫–µ—Ç —Å –¥–∞–Ω–Ω—ã–º–∏
        std::string data_packet = MessageProtocol::build(header, client_id, msg_id, message);

        // 2. –§–æ—Ä–º–∏—Ä—É–µ–º –ø–∞–∫–µ—Ç —Å –µ–≥–æ –¥–ª–∏–Ω–æ–π
        std::string length_str = std::to_string(data_packet.size());
        std::string length_packet = MessageProtocol::build("LENGTH", "server", -1, length_str);

        // 3. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–∞–∫–µ—Ç —Å –¥–ª–∏–Ω–æ–π
        if (send_packet(socket, length_packet) != 0) {
            std::cerr << "[ERROR] [send_formatted_message] Failed to send LENGTH packet." << std::endl;
            return -1;
        }

        // 4. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –ø–∞–∫–µ—Ç —Å –¥–∞–Ω–Ω—ã–º–∏
        if (send_packet(socket, data_packet) != 0) {
            std::cerr << "[ERROR] [send_formatted_message] Failed to send DATA packet." << std::endl;
            return -1;
        }

        return 0;
    }
    // --- –ù–û–í–û–ï: –ü—Ä–∏–≤–∞—Ç–Ω–∞—è –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è ---
    namespace {
        /**
         * @brief –ù–∞–¥–µ–∂–Ω–æ —á–∏—Ç–∞–µ—Ç —Ä–æ–≤–Ω–æ `bytes_to_receive` –±–∞–π—Ç –∏–∑ —Å–æ–∫–µ—Ç–∞.
         * –ë–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è, –ø–æ–∫–∞ –≤—Å–µ –±–∞–π—Ç—ã –Ω–µ –±—É–¥—É—Ç –ø–æ–ª—É—á–µ–Ω—ã.
         * @return –°—Ç—Ä–æ–∫–∞ —Å –¥–∞–Ω–Ω—ã–º–∏ –∏–ª–∏ –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ/—Ä–∞–∑—Ä—ã–≤–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è.
         */
        std::string receive_exact_bytes(int socket, size_t bytes_to_receive) {
            std::string result;
            result.reserve(bytes_to_receive);
            
            size_t total_received = 0;
            std::vector<char> buffer(bytes_to_receive > 4096 ? 4096 : bytes_to_receive);

            while (total_received < bytes_to_receive) {
                size_t to_read_now = bytes_to_receive - total_received;
                if (to_read_now > buffer.size()) {
                    to_read_now = buffer.size();
                }

                ssize_t bytes_this_call = recv(socket, buffer.data(), to_read_now, 0);

                if (bytes_this_call <= 0) { // –û—à–∏–±–∫–∞ –∏–ª–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ
                    if (bytes_this_call < 0) {
                        perror("[ERROR] [receive_exact_bytes] recv() failed");
                    }
                    return ""; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É
                }

                result.append(buffer.data(), bytes_this_call);
                total_received += bytes_this_call;
            }
            return result;
        }
    }

    // --- –ò–ó–ú–ï–ù–ï–ù–û: –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–ø–∏—Å–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ–≥–æ –ø—Ä–∏–µ–º–∞ ---
    std::optional<MessageProtocol::ParsedMessage> receive_and_parse_message(int socket, size_t buffer_size)
    {
        // 1. –ü—Ä–∏–Ω–∏–º–∞–µ–º –ø–µ—Ä–≤—ã–π –ø–∞–∫–µ—Ç (–æ–∂–∏–¥–∞–µ–º, —á—Ç–æ —ç—Ç–æ –ø–∞–∫–µ—Ç —Å –¥–ª–∏–Ω–æ–π)
        // –ó–¥–µ—Å—å –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—ã–π receive_packet, —Ç.–∫. –º—ã –Ω–µ –∑–Ω–∞–µ–º —Ç–æ—á–Ω—ã–π —Ä–∞–∑–º–µ—Ä –ø–∞–∫–µ—Ç–∞ —Å –¥–ª–∏–Ω–æ–π,
        // –Ω–æ –º—ã –∑–Ω–∞–µ–º, —á—Ç–æ –æ–Ω –∫–æ—Ä–æ—Ç–∫–∏–π –∏ –ø—Ä–∏–¥–µ—Ç —Ü–µ–ª–∏–∫–æ–º.
        std::string length_packet_raw = ProtocolUtils::receive_packet(socket, buffer_size);
        if (length_packet_raw.empty()) {
            return std::nullopt; // –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ
        }

        // 2. –ü–∞—Ä—Å–∏–º –µ–≥–æ, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å –¥–ª–∏–Ω—É —Å–ª–µ–¥—É—é—â–µ–≥–æ –ø–∞–∫–µ—Ç–∞
        MessageProtocol::ParsedMessage parsed_length_msg;
        try {
            parsed_length_msg = MessageProtocol::parse(length_packet_raw);
        } catch (const std::exception& e) {
            std::cerr << "[ERROR] [receive_and_parse_message] Failed to parse LENGTH packet: " << e.what() << std::endl;
            return std::nullopt;
        }

        if (parsed_length_msg.header != "LENGTH") {
            std::cerr << "[ERROR] [receive_and_parse_message] Expected LENGTH packet, but got " << parsed_length_msg.header << std::endl;
            return std::nullopt;
        }

        // 3. –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –ø–∞–∫–µ—Ç–∞
        size_t payload_size = 0;
        try {
            payload_size = std::stoul(parsed_length_msg.message);
        } catch (const std::exception& e) {
            std::cerr << "[ERROR] [receive_and_parse_message] Invalid payload size in LENGTH packet: " << e.what() << std::endl;
            return std::nullopt;
        }

        // 4. –ß–∏—Ç–∞–µ–º –∏–∑ —Å–æ–∫–µ—Ç–∞ —Ä–æ–≤–Ω–æ `payload_size` –±–∞–π—Ç
        std::string data_packet_raw = receive_exact_bytes(socket, payload_size);
        if (data_packet_raw.empty()) {
            return std::nullopt; // –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ –≤–æ –≤—Ä–µ–º—è —á—Ç–µ–Ω–∏—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –ø–∞–∫–µ—Ç–∞
        }

        // 5. –ü–∞—Ä—Å–∏–º –æ—Å–Ω–æ–≤–Ω–æ–π –ø–∞–∫–µ—Ç –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        try {
            return MessageProtocol::parse(data_packet_raw);
        } catch (const std::exception& e) {
            std::cerr << "[ERROR] [receive_and_parse_message] Failed to parse DATA packet: " << e.what() << std::endl;
            return std::nullopt;
        }
    }
} // namespace ProtocolUtils


================================================================================
// –§–∞–π–ª: Protocol_utils/protocol_utils.h
================================================================================

#pragma once

#include <string>
#include "../Protocol/protocol.h" // –ù—É–∂–µ–Ω –¥–ª—è MessageProtocol::build/parse
#include <optional>
/**
 * @brief –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∏–º–µ–Ω –¥–ª—è —É—Ç–∏–ª–∏—Ç, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤–æ–π –ø–µ—Ä–µ–¥–∞—á–µ–π –¥–∞–Ω–Ω—ã—Ö –ø–æ –ø—Ä–æ—Ç–æ–∫–æ–ª—É.
 */
namespace ProtocolUtils {

    /**
     * @brief –ù–∞–¥–µ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø–∞–∫–µ—Ç –¥–∞–Ω–Ω—ã—Ö –≤ —Å–æ–∫–µ—Ç.
     * –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã, –¥–∞–∂–µ –µ—Å–ª–∏ —Å–∏—Å—Ç–µ–º–Ω—ã–π –≤—ã–∑–æ–≤
     * send() –æ—Ç–ø—Ä–∞–≤–∏—Ç –∏—Ö –ø–æ —á–∞—Å—Ç—è–º.
     * @param socket –î–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä —Å–æ–∫–µ—Ç–∞ –∫–ª–∏–µ–Ω—Ç–∞.
     * @param data –î–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏.
     * @return 0 –≤ —Å–ª—É—á–∞–µ —É—Å–ø–µ—Ö–∞, -1 –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ä–∞–∑—Ä—ã–≤ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è).
     */
    int send_packet(int socket, const std::string& data);

    /**
     * @brief –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –ø–∞–∫–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Å–æ–∫–µ—Ç–∞.
     * –ß–∏—Ç–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ–∫–µ—Ç–∞ –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –æ–Ω–∏ –µ—Å—Ç—å, –Ω–æ –Ω–µ –±–æ–ª–µ–µ —á–µ–º buffer_size.
     * @param socket –î–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä —Å–æ–∫–µ—Ç–∞ –∫–ª–∏–µ–Ω—Ç–∞.
     * @param buffer_size –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —á—Ç–µ–Ω–∏—è –∑–∞ –æ–¥–∏–Ω –≤—ã–∑–æ–≤.
     * @return –ü–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –≤–∏–¥–µ —Å—Ç—Ä–æ–∫–∏. –ï—Å–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –∏–ª–∏
     *         —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É.
     */
    std::string receive_packet(int socket, size_t buffer_size);
    /**
     * @brief –í—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ –ø—Ä–æ—Ç–æ–∫–æ–ª—É LENGTH + DATA.
     * –°–Ω–∞—á–∞–ª–∞ —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø–∞–∫–µ—Ç —Å –¥–ª–∏–Ω–æ–π, –∞ –∑–∞—Ç–µ–º - –æ—Å–Ω–æ–≤–Ω–æ–π –ø–∞–∫–µ—Ç —Å –¥–∞–Ω–Ω—ã–º–∏.
     * @return 0 –≤ —Å–ª—É—á–∞–µ —É—Å–ø–µ—Ö–∞, -1 –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏.
     */
    int send_formatted_message(int socket, const std::string& header, const std::string& client_id, int msg_id, const std::string& message);

    /**
     * @brief –í—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–µ–º–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ –ø—Ä–æ—Ç–æ–∫–æ–ª—É LENGTH + DATA.
     * –°–Ω–∞—á–∞–ª–∞ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∏ –ø–∞—Ä—Å–∏—Ç –ø–∞–∫–µ—Ç —Å –¥–ª–∏–Ω–æ–π, –∞ –∑–∞—Ç–µ–º –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω–æ–π –ø–∞–∫–µ—Ç.
     * @return –†–∞—Å–ø–∞—Ä—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ–ª–µ–∑–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞ (message). –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ.
     */
    std::optional<MessageProtocol::ParsedMessage> receive_and_parse_message(int socket, size_t buffer_size = 4096);

} // namespace ProtocolUtils

================================================================================
// –§–∞–π–ª: Client/client.cpp
================================================================================

#include "client.h"
#include <sys/ioctl.h>
#include <net/if.h>
void client::work(UI &intf)
{
    const std::string method_name = "client::work";
    std::cout << "[INFO] [" << method_name << "] –ù–∞—á–∞–ª–æ —Ä–∞–±–æ—Ç—ã –∫–ª–∏–µ–Ω—Ç–∞." << std::endl;

    // –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    serv_ip = intf.get_serv_ip().c_str();
    port = intf.get_port();
    op = intf.get_op();
    password = intf.get_password();
    id = intf.get_username();

    start();
    connect_to_server();
    if (recv_data("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–µ–º–µ —Ñ–ª–∞–≥–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ—Å—Ç–∏ —Å–µ—Ä–≤–µ—Ä–∞") == "–°–µ—Ä–≤–µ—Ä –ø–æ–ª–æ–Ω")
    {
        close_sock();
        std::cout << "[INFO] [" << method_name << "] –°–µ—Ä–≤–µ—Ä –ø–æ–ª–æ–Ω" << std::endl;
        exit(1);
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(10));

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–∏–ø –æ–ø–µ—Ä–∞—Ü–∏–∏ (—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è / –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è)
    send_data("OP", id, 0, std::to_string(op));

    if (op == 1)
    {
        std::cout << "[INFO] [" << method_name << "] –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞..." << std::endl;
        client_auth();
        std::cout << "[INFO] [" << method_name << "] –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞." << std::endl;
    }
    else
    {
        std::cout << "[INFO] [" << method_name << "] –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞..." << std::endl;
        client_reg();
        std::cout << "[INFO] [" << method_name << "] –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞." << std::endl;
    }

    // –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
    while (true)
    {
        int operation;
        std::cout << "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –æ–ø–µ—Ä–∞—Ü–∏–∏:\n‚Ä¢11 - –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞ –Ω–∞ –ø–æ–¥–ø–∏—Å—å –±–µ–∑ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–æ–≤—ã—Ö –∫–ª—é—á–µ–π\n‚Ä¢22 - –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏\n‚Ä¢111 - –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞ –Ω–∞ –ø–æ–¥–ø–∏—Å—å —Å –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π –Ω–æ–≤—ã—Ö –∫–ª—é—á–µ–π\n‚Ä¢0 - –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã\n –í–∞—à –≤—ã–±–æ—Ä -> ";
        std::cin >> operation;
        try
        {
            switch (operation)
            {
            case 11:
            {
                send_data("OP", id, 0, std::to_string(operation));
                std::string file_path;
                std::cout << "[INPUT] –í–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –¥–∞–Ω–Ω—ã—Ö: " << std::endl;
                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
                std::getline(std::cin, file_path);
                std::cout << "[INFO] [" << method_name << "] –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ö–µ—à–∞ –ø–æ —Ñ–∞–π–ª—É: " << file_path << std::endl;
                std::string hash = hash_gen_file(file_path);
                std::cout << "[INFO] [" << method_name << "] –û—Ç–ø—Ä–∞–≤–∫–∞ —Ö–µ—à–∞ —Ñ–∞–π–ª–∞ –¥–ª—è –ø–æ–¥–ø–∏—Å–∏: " << hash << std::endl;
                send_data("SND_FILE_256", id, 1, hash);
                std::cout << "[INFO] [" << method_name << "] –•–µ—à —Ñ–∞–π–ª–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –ø–æ–¥–ø–∏—Å—å: " << hash << std::endl;
                std::string sig = recv_data("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–µ–º–µ –ø–æ–¥–ø–∏—Å–∏");
                std::cout << "–ü–æ–¥–ø–∏—Å—å: " << sig << std::endl;
                file_path.erase(file_path.find_last_of('.'));
                saveKeyToFile("signature_" + file_path + ".bin", BigInt::fromHexString(sig));
                break;
            }
            case 22:
            {
                send_data("OP", id, 0, std::to_string(operation));
                std::cout << "[INPUT] –û–∂–∏–¥–∞–Ω–∏–µ –∫–ª—é—á–µ–π" << std::endl;

                std::string open_key = recv_data("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–µ–º–µ –æ—Ç–∫—Ä—ã—Ç–æ–≥–æ –∫–ª—é—á–∞");
                std::string eksp = recv_data("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–µ–º–µ —ç–∫—Å–ø–æ–Ω–µ–Ω—Ç—ã");

                std::cout << "–û—Ç–∫—Ä—ã—Ç—ã–π –∫–ª—é—á: " << open_key << std::endl;
                std::cout << "–≠–∫—Å–ø–æ–Ω–µ–Ω—Ç–∞: " << eksp << std::endl;

                std::string sig_path, file_path;
                std::cout << "[INPUT] –í–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É —Å –ø–æ–¥–ø–∏—Å—å—é: ";
                std::cin >> sig_path;

                std::cout << "[INPUT] –í–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É —Å –¥–∞–Ω–Ω—ã–º–∏: ";
                std::cin >> file_path;

                std::cout << "[INFO] [" << method_name << "] –ù–∞—á–∞–ª–æ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∏" << std::endl;

                BigInt sig, e, n;
                e = BigInt::fromHexString(eksp);
                n = BigInt::fromHexString(open_key);
                sig = loadKeyFromFile(sig_path);

                BigInt verifiedHash = rsa_mod_exp(sig, e, n);
                std::cout << "\nüîç Verified hash: ";
                verifiedHash.printHex();

                std::string hash_file = hash_gen_file(file_path);
                std::cout << "\nüéØ Original hash (as BigInt): " << hash_file << std::endl;

                if (verifiedHash.toHexString() == hash_file)
                {
                    std::cout << "\n‚úÖ The signature is confirmed: The hashes match!\n";
                }
                else
                {
                    std::cout << "\n‚ùå The signature is not confirmed: The hashes do not match!\n";
                }
                break;
            }
            case 111:
            {
                send_data("OP", id, 0, std::to_string(operation));
                std::string file_path;
                std::cout << "[INPUT] –í–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –¥–∞–Ω–Ω—ã—Ö: " << std::endl;
                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
                std::getline(std::cin, file_path);
                std::cout << "[INFO] [" << method_name << "] –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ö–µ—à–∞ –ø–æ —Ñ–∞–π–ª—É: " << file_path << std::endl;
                std::string hash = hash_gen_file(file_path);
                std::cout << "[INFO] [" << method_name << "] –û—Ç–ø—Ä–∞–≤–∫–∞ —Ö–µ—à–∞ —Ñ–∞–π–ª–∞ –¥–ª—è –ø–æ–¥–ø–∏—Å–∏: " << hash << std::endl;
                send_data("SND_FILE_256", id, 1, hash);
                std::cout << "[INFO] [" << method_name << "] –•–µ—à —Ñ–∞–π–ª–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –ø–æ–¥–ø–∏—Å—å: " << hash << std::endl;
                std::string sig = recv_data("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–µ–º–µ –ø–æ–¥–ø–∏—Å–∏");
                std::cout << "–ü–æ–¥–ø–∏—Å—å: " << sig << std::endl;
                file_path.erase(file_path.find_last_of('.'));
                saveKeyToFile("signature_" + file_path + ".bin", BigInt::fromHexString(sig));
                break;
            }
            case 0:
            {
                send_data("OP", id, 0, std::to_string(operation));
                std::cout << "[INFO] –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã" << std::endl;
                exit(1);
            }

            default:
                std::cout << "[ERROR] –í—ã–±—Ä–∞–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø –æ–ø–µ—Ä–∞—Ü–∏–∏" << std::endl;
                break;
            }
        }catch (const std::exception &ex)
                {
                    std::string err = recv_data("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–µ–º–µ –ø–æ–¥–ø–∏—Å–∏");
                    std::cerr << "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: " << err << std::endl;
                    exit(1);
                }
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    close_sock();
    std::cout << "[INFO] [" << method_name << "] –ö–ª–∏–µ–Ω—Ç –∑–∞–≤–µ—Ä—à–∏–ª —Ä–∞–±–æ—Ç—É." << std::endl;
    exit(1);
}

void client::client_reg()
{
    const std::string method_name = "client::client_reg";

    std::cout << "[INFO] [" << method_name << "] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è..." << std::endl;

    std::cout << "[INFO] [" << method_name << "] –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ö—ç—à–∞ –ø–∞—Ä–æ–ª—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä..." << std::endl;
    std::string hashed_password = hash_gen(password);

    std::cout << "[INFO] [" << method_name << "] –û—Ç–ø—Ä–∞–≤–∫–∞ —Ö—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–∞—Ä–æ–ª—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä..." << std::endl;
    send_data("REG_PASS", id, 0, hashed_password);

    std::cout << "[INFO] [" << method_name << "] –û–∂–∏–¥–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞..." << std::endl;
    std::string answ = recv_data("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–Ω—è—Ç–∏–∏ –æ—Ç–≤–µ—Ç–∞ –æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Å —Å–µ—Ä–≤–µ—Ä–∞");

    if (answ != "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞")
    {
        std::cout << "[ERROR] [" << method_name << "] –§–ª–∞–≥ –æ—à–∏–±–∫–∏: " << answ << std::endl;
        close_sock();
        debugger.show_error_information("–û—à–∏–±–∫–∞ –≤ client_reg()", "–í–æ–∑–º–æ–∂–Ω–∞—è –ø—Ä–∏—á–∏–Ω–∞ - –æ—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ –ë–î –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ", "–õ–æ–≥–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞");
        exit(1);
    }

    std::cout << "[INFO] [" << method_name << "] –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è." << std::endl;
    close_sock();

    std::cout << "[INFO] [" << method_name << "] –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã –∫–ª–∏–µ–Ω—Ç–∞." << std::endl;
    exit(0);
}

void client::client_auth()
{
    const std::string method_name = "client::client_auth";
    std::chrono::milliseconds duration(30);

    std::cout << "[INFO] [" << method_name << "] –ù–∞—á–∞–ª–æ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏..." << std::endl;
    std::this_thread::sleep_for(duration);

    // –û—Ç–ø—Ä–∞–≤–∫–∞ —Ö—ç—à–∞ –ø–∞—Ä–æ–ª—è
    std::string hashed_password = hash_gen(password);
    std::cout << "[INFO] [" << method_name << "] –û—Ç–ø—Ä–∞–≤–∫–∞ —Ö—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–∞—Ä–æ–ª—è..." << std::endl;
    send_data("AUTH_PASS", id, 0, hashed_password);
    std::this_thread::sleep_for(duration);

    // –û—Ç–ø—Ä–∞–≤–∫–∞ IP-–∞–¥—Ä–µ—Å–∞ –∫–ª–∏–µ–Ω—Ç–∞
    std::cout << "[INFO] [" << method_name << "] –û—Ç–ø—Ä–∞–≤–∫–∞ IP-–∞–¥—Ä–µ—Å–∞ –∫–ª–∏–µ–Ω—Ç–∞..." << std::endl;
    send_data("AUTH_IP", id, 0, ip);
    std::this_thread::sleep_for(duration);

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
    std::cout << "[INFO] [" << method_name << "] –û–∂–∏–¥–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞..." << std::endl;
    std::string flag = recv_data("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–Ω—è—Ç–∏–∏ –æ—Ç–≤–µ—Ç–∞ –æ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ —Å —Å–µ—Ä–≤–µ—Ä–∞");

    if (flag != "–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞")
    {
        std::cout << "[ERROR] [" << method_name << "] –§–ª–∞–≥ –æ—à–∏–±–∫–∏: " << flag << std::endl;
        debugger.show_error_information("–û—à–∏–±–∫–∞ –≤ client_auth()", "UERR - –Ω–µ–≤–µ—Ä–Ω–æ–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è \nPERR - –Ω–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å \nIERR - –Ω–µ–≤–µ—Ä–Ω—ã–π –∞–π–ø–∏", "–õ–æ–≥–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞");
        close_sock();
        exit(1);
    }

    std::cout << "[INFO] [" << method_name << "] –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ." << std::endl;
}

void client::start()
{
    std::cout << "[INFO] –ù–∞—á–∞–ª–æ —Å–æ–∑–¥–∞–Ω–∏—è —Å–æ–∫–µ—Ç–∞..." << std::endl;

    // –°–æ–∑–¥–∞–µ–º —Å–æ–∫–µ—Ç
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0)
    {
        debugger.show_error_information("–û—à–∏–±–∫–∞ –≤ start()", "–í–æ–∑–º–æ–∂–Ω–∞—è –ø—Ä–∏—á–∏–Ω–∞ - –Ω–µ–≤–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã socket()", "–°–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞");
        std::cerr << "[ERROR] –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å–æ–∫–µ—Ç!" << std::endl;
        return;
    }

    std::cout << "[INFO] –°–æ–∫–µ—Ç —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω" << std::endl;

    // –ù–∞—Å—Ç—Ä–æ–∏–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(port);

    std::cout << "[INFO] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∞–¥—Ä–µ—Å–∞ —Å–µ—Ä–≤–µ—Ä–∞: " << serv_ip << ":" << port << std::endl;
    inet_pton(AF_INET, serv_ip, &serverAddr.sin_addr);

    std::cout << "[INFO] –ê–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞ —É—Å–ø–µ—à–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω" << std::endl;
}

void client::connect_to_server()
{
    const std::string method_name = "client::connect_to_server";
    std::cout << "[INFO] [" << method_name << "] –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ª–æ–∫–∞–ª—å–Ω–æ–º —Å–æ–∫–µ—Ç–µ..." << std::endl;
    sockaddr_in localAddr{};
    socklen_t addrLen = sizeof(localAddr);

    // –ü–æ–ª—É—á–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –∞–¥—Ä–µ—Å —Å–æ–∫–µ—Ç–∞
    if (getsockname(sock, (struct sockaddr *)&localAddr, &addrLen) < 0)
    {
        std::cerr << "[ERROR] [" << method_name << "] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–æ–∫–µ—Ç–µ" << std::endl;
        return;
    }
    std::cout << "[INFO] [" << method_name << "] –õ–æ–∫–∞–ª—å–Ω—ã–π –∞–¥—Ä–µ—Å —Å–æ–∫–µ—Ç–∞ –ø–æ–ª—É—á–µ–Ω: " << inet_ntoa(localAddr.sin_addr) << std::endl;

    // –ü—Ä–æ–≤–µ—Ä–∫–∞, –µ—Å–ª–∏ IP —Å–µ—Ä–≤–µ—Ä–∞ —Ä–∞–≤–µ–Ω 127.0.0.1 (–ª–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä)
    if (serverAddr.sin_addr.s_addr == htonl(INADDR_LOOPBACK))
    {
        ip = "127.0.0.1"; // –ï—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –ª–æ–∫–∞–ª—å–Ω—ã–π
        std::cout << "[INFO] [" << method_name << "] –°–µ—Ä–≤–µ—Ä –ª–æ–∫–∞–ª—å–Ω—ã–π. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è IP: 127.0.0.1" << std::endl;
    }
    else
    {
        struct ifreq ifr;
        strncpy(ifr.ifr_name, "enp4s0", IFNAMSIZ - 1);
        if (ioctl(sock, SIOCGIFADDR, &ifr) == -1)
        {
            perror("ioctl");
            close(sock);
            return;
        }
        char ipp[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr, ipp, sizeof(ipp));
        ip = ipp;
        std::cout << "[INFO] [" << method_name << "] –°–µ—Ä–≤–µ—Ä –Ω–µ –ª–æ–∫–∞–ª—å–Ω—ã–π. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è IP: " << ip << std::endl;
    }

    // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É
    std::cout << "[INFO] [" << method_name << "] –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É..." << std::endl;
    if (connect(sock, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0)
    {
        close_sock();
        std::cerr << "[ERROR] [" << method_name << "] –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ IP –∏–ª–∏ –ø–æ—Ä—Ç." << std::endl;
        debugger.show_error_information("–û—à–∏–±–∫–∞ –≤ connect_to_server()", "–í–æ–∑–º–æ–∂–Ω–∞—è –ø—Ä–∏—á–∏–Ω–∞ - –Ω–µ–≤–µ—Ä–Ω—ã–π –∞–π–ø–∏ –∏–ª–∏ –ø–æ—Ä—Ç —Å–µ—Ä–≤–µ—Ä–∞", "–õ–æ–≥–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞");
        return;
    }

    std::cout << "[INFO] [" << method_name << "] –ö–ª–∏–µ–Ω—Ç —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É" << std::endl;

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–ª–∏–µ–Ω—Ç–∞ —Å –∑–∞–≥–æ–ª–æ–≤–∫–æ–º
    std::cout << "[INFO] [" << method_name << "] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–ª–∏–µ–Ω—Ç–∞: " << id << std::endl;
    send_data("CLIENT_ID", id, 0, id);
}
// (send_data unchanged above)

std::string client::recv_data(std::string error_msg)
{
    const std::string method_name = "recv_data";

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–∞—É—Ç –Ω–∞ –ø—Ä–∏—ë–º –¥–∞–Ω–Ω—ã—Ö
    timeout.tv_sec = 100;
    timeout.tv_usec = 0;
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout));

    // 1) –ü—Ä–∏–Ω—è—Ç—å –ø–∞–∫–µ—Ç LENGTH, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π —Ä–∞–∑–º–µ—Ä —Å–ª–µ–¥—É—é—â–µ–≥–æ DATA-–ø–∞–∫–µ—Ç–∞
    std::vector<char> len_buf(buflen);
    int len_bytes = recv(sock, len_buf.data(), buflen, MSG_NOSIGNAL);
    if (len_bytes <= 0)
    {
        // close_sock();
        std::cerr << "[ERROR] [" << method_name << "] " << error_msg << " (LENGTH)" << std::endl;
        return "";
    }
    // —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å LENGTH-–ø–∞–∫–µ—Ç —Ü–µ–ª–∏–∫–æ–º
    std::string len_raw(len_buf.data(), len_bytes);
    MessageProtocol::ParsedMessage len_msg;
    try
    {
        len_msg = MessageProtocol::parse(len_raw);
    }
    catch (const std::exception &e)
    {
        std::cerr << "[ERROR] [" << method_name << "] –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ LENGTH: " << e.what() << std::endl;
        return "";
    }
    int payload_size = 0;
    try
    {
        payload_size = std::stoi(len_msg.message);
    }
    catch (...)
    {
        std::cerr << "[ERROR] [" << method_name << "] –ù–µ–≤–µ—Ä–Ω—ã–π —Ä–∞–∑–º–µ—Ä payload: " << len_msg.message << std::endl;
        return "";
    }

    // 2) –ü—Ä–∏–Ω—è—Ç—å DATA-–ø–∞–∫–µ—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
    std::vector<char> data_buf;
    data_buf.reserve(payload_size);
    int total = 0;
    while (total < payload_size)
    {
        int to_read = std::min(buflen, payload_size - total);
        int r = recv(sock, len_buf.data(), to_read, 0);
        if (r <= 0)
        {
            // close_sock();
            std::cerr << "[ERROR] [" << method_name << "] " << error_msg << " (DATA)" << std::endl;
            return "";
        }
        data_buf.insert(data_buf.end(), len_buf.data(), len_buf.data() + r);
        total += r;
    }

    // —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å DATA-–ø–∞–∫–µ—Ç
    std::string data_raw(data_buf.data(), data_buf.size());
    try
    {
        auto pm = MessageProtocol::parse(data_raw);
        return pm.message;
    }
    catch (const std::exception &e)
    {
        std::cerr << "[ERROR] [" << method_name << "] –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ DATA: " << e.what() << std::endl;
        return "";
    }
}

void client::close_sock()
{
    std::cout << "[INFO] –ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–∫–µ—Ç–∞ –∫–ª–∏–µ–Ω—Ç–∞..." << std::endl;

    // –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–∫—Ä—ã—Ç—å —Å–æ–∫–µ—Ç
    if (close(sock) == 0)
    {
        std::cout << "[INFO] –°–æ–∫–µ—Ç –∫–ª–∏–µ–Ω—Ç–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—Ä—ã—Ç" << std::endl;
    }
    else
    {
        // –ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏
        std::cerr << "[ERROR] –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Å–æ–∫–µ—Ç–∞ –∫–ª–∏–µ–Ω—Ç–∞" << std::endl;
    }
}

void client::send_data(const std::string &header,
                       const std::string &client_id, int message_id,
                       const std::string &msg)
{
    const std::string method_name = "send_data";

    if (sock < 0)
    {
        std::cerr << "[ERROR] [" << method_name << "] –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å–æ–∫–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞" << std::endl;
        return;
    }

    std::cout << "[INFO] [" << method_name << "] –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä—É" << std::endl;

    std::string packet = MessageProtocol::build(header, client_id, message_id, msg);

    std::this_thread::sleep_for(std::chrono::milliseconds(10)); // –ø–∞—É–∑–∞

    size_t total_sent = 0;
    while (total_sent < packet.size())
    {
        int sent_now = send(sock, packet.c_str() + total_sent, packet.size() - total_sent, 0);
        if (sent_now <= 0)
        {
            std::cerr << "[ERROR] [" << method_name << "] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–µ—Ä–≤–µ—Ä—É –¥–∞–Ω–Ω—ã—Ö" << std::endl;
            close_sock();
            return;
        }
        total_sent += sent_now;
    }

    std::cout << "[INFO] [" << method_name << "] –£—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ " << total_sent << " –±–∞–π—Ç —Å–µ—Ä–≤–µ—Ä—É " << std::endl;
}

std::string client::hash_gen_file(std::string filename)
{
    try
    {
        CryptoPP::SHA256 hash;
        std::string digest;

        CryptoPP::FileSource file(filename.c_str(), true,
                                  new CryptoPP::HashFilter(hash,
                                                           new CryptoPP::HexEncoder(
                                                               new CryptoPP::StringSink(digest))));

        return digest;
    }
    catch (const CryptoPP::Exception &ex)
    {
        throw std::runtime_error(std::string("Crypto++ error: ") + ex.what());
    }
}
std::string client::hash_gen(std::string password)
{
    // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –¥–ª—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è SHA256
    CryptoPP::SHA256 hash;
    std::string hashed_password;

    // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ:
    // StringSource - –∏—Å—Ç–æ—á–Ω–∏–∫ –¥–∞–Ω–Ω—ã—Ö (—Å—Ç—Ä–æ–∫–∞ —Å –ø–∞—Ä–æ–ª–µ–º), –ø–µ—Ä–µ–¥–∞–µ–º –µ–≥–æ –≤ —Ö—ç—à-—Ñ–∏–ª—å—Ç—Ä
    // HashFilter - —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç –∏ —Ö—ç—à–∏—Ä—É–µ—Ç –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ –∞–ª–≥–æ—Ä–∏—Ç–º SHA256
    // HexEncoder - –∫–æ–¥–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è –≤ —Å—Ç—Ä–æ–∫—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
    // StringSink - –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –≤–∏–¥–µ —Å—Ç—Ä–æ–∫–∏
    CryptoPP::StringSource(password, true,
                           new CryptoPP::HashFilter(hash,
                                                    new CryptoPP::HexEncoder(
                                                        new CryptoPP::StringSink(hashed_password))));

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ö—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É –ø–∞—Ä–æ–ª—è
    return hashed_password;
}

================================================================================
// –§–∞–π–ª: Client/client.h
================================================================================

#pragma once
#include <iostream>
#include <string>
#include <vector>
#include <cstring>
#include <algorithm>
#include <memory>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <random>
#include <chrono>
#include <algorithm>
#include <thread>
#include <limits>
#include "show_error.h"
#include "ui.h"
#include <cryptopp/cryptlib.h>
#include <cryptopp/hex.h>
#include <cryptopp/files.h>
#include <cryptopp/sha.h> 
#include <cryptopp/filters.h>
#include <cryptopp/osrng.h>
#include <iomanip>
#include "protocol.h"
#include "rsa_crypto.h"
class client {
    private:
        show_error debugger;
        timeval timeout{};
        std::string hash;
        std::string password;
        std::string id;
        std::string ip;
        struct sockaddr_in serverAddr;
        socklen_t addr_size;
        int buflen = 65600;
        std::unique_ptr<char[]> buffer{new char[buflen]};
        uint port;
        uint op;
        std::ifstream u_data;
        std::string hash_gen(std::string password);
        std::string hash_gen_file(std::string password);
    public:
        const char* serv_ip;
        int sock;
        std::vector <std::string> files;
        void connect_to_server();
        void send_data(const std::string& header, const std::string& client_id, int message_id, const std::string& msg);
        std::string recv_data(std::string error_msg);
        void close_sock();
        void start();
        void work(UI &intf);
        void client_auth();
        void client_reg();
        std::vector<std::string> recv_vector();
        void print_vector(const std::vector<std::string>& vec);
        int recv_file(std::string& file_path);
};

================================================================================
// –§–∞–π–ª: Crypto_utils/crypto_utils.cpp
================================================================================

#include "crypto_utils.h"

// --- –ó–∞–≥–æ–ª–æ–≤–æ—á–Ω—ã–µ —Ñ–∞–π–ª—ã Crypto++ ---
// –î–ª—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è (SHA-256)
#include "cryptopp/sha.h"

// –î–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª
#include "cryptopp/osrng.h" // AutoSeededRandomPool

// –î–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è/–¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —Ä–∞–±–æ—Ç—ã —Å –ø–æ—Ç–æ–∫–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö
#include "cryptopp/filters.h" // StringSource, HashFilter, ...
#include "cryptopp/hex.h"     // HexEncoder
#include "cryptopp/secblock.h" // SecByteBlock


namespace CryptoUtils {

// –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
std::string generate_hash(const std::string& input) {
    // 1. –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è SHA-256.
    CryptoPP::SHA256 hash_algorithm;

    // 2. –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä–æ–∫—É, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –≤–∏–¥–µ –¥–∞–π–¥–∂–µ—Å—Ç–∞.
    std::string digest;

    // 3. –°–æ–∑–¥–∞–µ–º "–∫–æ–Ω–≤–µ–π–µ—Ä" –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö:
    //    - StringSource: –ò—Å—Ç–æ—á–Ω–∏–∫ –¥–∞–Ω–Ω—ã—Ö - –Ω–∞—à–∞ –≤—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ 'input'.
    //    - HashFilter: –§–∏–ª—å—Ç—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–º–µ–Ω—è–µ—Ç –∫ –¥–∞–Ω–Ω—ã–º 'hash_algorithm'.
    //    - HexEncoder: –ö–æ–¥–∏—Ä–æ–≤—â–∏–∫, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –±–∏–Ω–∞—Ä–Ω—ã–π –¥–∞–π–¥–∂–µ—Å—Ç –≤ HEX-—Å—Ç—Ä–æ–∫—É.
    //    - StringSink: "–ü—Ä–∏–µ–º–Ω–∏–∫" –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–º–µ—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ —Å—Ç—Ä–æ–∫—É 'digest'.
    //    –ü–∞—Ä–∞–º–µ—Ç—Ä 'true' –≤ StringSource –æ–∑–Ω–∞—á–∞–µ—Ç "putNextMessage".
    CryptoPP::StringSource(input, true, 
        new CryptoPP::HashFilter(hash_algorithm,
            new CryptoPP::HexEncoder(
                new CryptoPP::StringSink(digest)
            )
        )
    );

    return digest;
}


// –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–ª—É—á–∞–π–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
std::string generate_random_hex_string(size_t byte_length) {
    // 1. –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ —Å—Ç–æ–π–∫–æ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –ø—Å–µ–≤–¥–æ—Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª (CSPRNG).
    //    AutoSeededRandomPool –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ "–∑–∞—Å–µ–∏–≤–∞–µ—Ç—Å—è" —ç–Ω—Ç—Ä–æ–ø–∏–µ–π –∏–∑ –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã,
    //    —á—Ç–æ –¥–µ–ª–∞–µ—Ç –µ–≥–æ –Ω–µ–ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã–º.
    CryptoPP::AutoSeededRandomPool prng;

    // 2. –°–æ–∑–¥–∞–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –±–ª–æ–∫ –±–∞–π—Ç (SecByteBlock) –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–ª—É—á–∞–π–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö.
    //    SecByteBlock –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω—É–ª—è–µ—Ç –ø–∞–º—è—Ç—å –ø—Ä–∏ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–∏, —á—Ç–æ–±—ã
    //    –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏—Ç—å —É—Ç–µ—á–∫—É —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö.
    CryptoPP::SecByteBlock random_bytes(byte_length);
    
    // 3. –ó–∞–ø–æ–ª–Ω—è–µ–º –±–ª–æ–∫ —Å–ª—É—á–∞–π–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏.
    prng.GenerateBlock(random_bytes, random_bytes.size());

    // 4. –ö–æ–¥–∏—Ä—É–µ–º —Å—ã—Ä—ã–µ –±–∞–π—Ç—ã –≤ —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—É—é —Å—Ç—Ä–æ–∫—É.
    std::string hex_encoded_string;
    CryptoPP::StringSource(random_bytes, random_bytes.size(), true,
        new CryptoPP::HexEncoder(
            new CryptoPP::StringSink(hex_encoded_string)
        )
    );

    return hex_encoded_string;
}

} // namespace CryptoUtils

================================================================================
// –§–∞–π–ª: Crypto_utils/crypto_utils.h
================================================================================

// crypto_utils.h
#pragma once
#include <string>

namespace CryptoUtils {
    // –•–µ—à–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É —Å –ø–æ–º–æ—â—å—é SHA-256 –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç HEX
    std::string generate_hash(const std::string& input);

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫—Ä–∏–ø—Ç–æ-—Å—Ç–æ–π–∫—É—é —Å–ª—É—á–∞–π–Ω—É—é HEX-—Å—Ç—Ä–æ–∫—É
    std::string generate_random_hex_string(size_t byte_length);
}

================================================================================
// –§–∞–π–ª: UI/ui.cpp
================================================================================

#include "ui.h"
#include <boost/program_options.hpp>
namespace po = boost::program_options;
UI::UI(int argc, char *argv[])
{
    // –û–ø–∏—Å–∞–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ —Å –ø–æ–º–æ—â—å—é Boost.Program_options
    desc.add_options()
        ("help,h", "–ü–æ–º–æ—â—å\n–í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–∏–∂–µ —è–≤–ª—è—é—Ç—Å—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º–∏")
        ("serv_ip,s", po::value<std::vector<std::string>>()->multitoken(), "–ê–π–ø–∏ —Å–µ—Ä–≤–µ—Ä–∞")
        ("operation, o", po::value<std::vector<uint>>()->multitoken(), "1 - –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è, 0 - —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è")
        ("username, u", po::value<std::vector<std::string>>()->multitoken(), "–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
        ("password, pa", po::value<std::vector<std::string>>()->multitoken(), "–ü–∞—Ä–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
        ("port,p", po::value<std::vector<uint>>()->multitoken(), "–ü–æ—Ä—Ç —Å–µ—Ä–≤–µ—Ä–∞");

    // –†–∞–∑–±–æ—Ä –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É vm
    po::store(po::parse_command_line(argc, argv, desc), vm);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    if (vm.count("help") or !vm.count("serv_ip") or !vm.count("port")) {
        std::cout << desc << std::endl;  // –í—ã–≤–æ–¥ —Å–ø—Ä–∞–≤–∫–∏
        exit(0);  // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã
    }

    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    po::notify(vm);
}
// –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
std::string UI::get_username(){
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ "username" –∏ –Ω–µ–ø—É—Å—Ç–æ—Ç—É –≤–µ–∫—Ç–æ—Ä–∞ –∑–Ω–∞—á–µ–Ω–∏–π
    if (vm.count("username") and !vm["username"].as<std::vector<std::string>>().empty())
    {
        // –ü–æ–ª—É—á–∞–µ–º –≤–µ–∫—Ç–æ—Ä –∏–º—ë–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤–≤–µ–¥—ë–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        const std::vector<std::string> &username = vm["username"].as<std::vector<std::string>>();
        return username.back();
    }
    else
    {
        // –ï—Å–ª–∏ –∏–º—è –Ω–µ —É–∫–∞–∑–∞–Ω–æ ‚Äî –≤—ã–≤–æ–¥–∏–º —Å–ø—Ä–∞–≤–∫—É –∏ –≤—ã–∑—ã–≤–∞–µ–º –æ—Ç–ª–∞–¥—á–∏–∫ —Å –æ—à–∏–±–∫–æ–π
        std::cout << desc << std::endl;
        debugger.show_error_information("–û—à–∏–±–∫–∞ –≤ get_username()", "–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", "–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞");
        return "";
    }
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–∏–ø–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏ (—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∏–ª–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è)
uint UI::get_op(){
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ "operation" –∏ –Ω–µ–ø—É—Å—Ç–æ—Ç—É –≤–µ–∫—Ç–æ—Ä–∞ –∑–Ω–∞—á–µ–Ω–∏–π
    if (vm.count("operation") and !vm["operation"].as<std::vector<uint>>().empty())
    {
        const std::vector<uint> &op = vm["operation"].as<std::vector<uint>>();
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è: 0 (—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è) –∏–ª–∏ 1 (–∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è)
        if (op.back()>1 or op.back()<0)
        {
            std::cout << desc << std::endl;
            debugger.show_error_information("–û—à–∏–±–∫–∞ –≤ get_op()", "–ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä –æ–ø–µ—Ä–∞—Ü–∏–∏", "–õ–æ–≥–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞");
            return 2; // 2 = –æ—à–∏–±–∫–∞
        }
        return op.back();
    }
    else
    {
        // –ï—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äî –≤—ã–≤–æ–¥–∏–º —Å–ø—Ä–∞–≤–∫—É –∏ –æ—à–∏–±–∫—É
        std::cout << desc << std::endl;
        debugger.show_error_information("–û—à–∏–±–∫–∞ –≤ get_op()", "–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏", "–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞");
        return 2;
    }
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–∞—Ä–æ–ª—è
std::string UI::get_password(){
    if (vm.count("password") and !vm["password"].as<std::vector<std::string>>().empty())
    {
        const std::vector<std::string> &password = vm["password"].as<std::vector<std::string>>();
        return password.back(); // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π –ø–∞—Ä–æ–ª—å
    }
    else
    {
        std::cout << desc << std::endl;
        debugger.show_error_information("–û—à–∏–±–∫–∞ –≤ get_password()", "–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–æ–ª—è", "–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞");
        return "";
    }
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–º–µ—Ä–∞ –ø–æ—Ä—Ç–∞
uint UI::get_port()
{
    if (vm.count("port") and !vm["port"].as<std::vector<uint>>().empty())
    {
        const std::vector<uint> &ports = vm["port"].as<std::vector<uint>>();
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –ø–æ—Ä—Ç–æ–≤
        if (ports.back() < 1024)
        {
            std::cout << desc << std::endl;
            debugger.show_error_information("–û—à–∏–±–∫–∞ –≤ get_port()", "–í—ã–±—Ä–∞–Ω–Ω—ã–π –ø–æ—Ä—Ç –º–µ–Ω—å—à–µ 1024", "–õ–æ–≥–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞");
            return 1;
        }
        if (ports.back() > 65535)
        {
            std::cout << desc << std::endl;
            debugger.show_error_information("–û—à–∏–±–∫–∞ –≤ get_port()", "–í—ã–±—Ä–∞–Ω–Ω—ã–π –ø–æ—Ä—Ç –±–æ–ª—å—à–µ 65535", "–õ–æ–≥–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞");
            return 1;
        }

        return ports.back();
    }
    else
    {
        // –ï—Å–ª–∏ –ø–æ—Ä—Ç –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω ‚Äî –≤—ã–≤–æ–¥–∏–º —Å–ø—Ä–∞–≤–∫—É –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
        std::cout << desc << std::endl;
        debugger.show_error_information("–û—à–∏–±–∫–∞ –≤ get_port()", "–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ—Ä—Ç–∞", "–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞");
        return 1;
    }
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ IP-–∞–¥—Ä–µ—Å–∞ —Å–µ—Ä–≤–µ—Ä–∞
std::string UI::get_serv_ip()
{
    struct in_addr addr; // –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∞–¥—Ä–µ—Å–∞ –≤ –¥–≤–æ–∏—á–Ω–æ–º –≤–∏–¥–µ

    if (vm.count("serv_ip") and !vm["serv_ip"].as<std::vector<std::string>>().empty())
    {
        const std::vector<std::string> &ip_s = vm["serv_ip"].as<std::vector<std::string>>();

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ —Ñ–æ—Ä–º–∞—Ç–∞ IP (–¥–æ–ª–∂–µ–Ω –±—ã—Ç—å IPv4)
        if (inet_pton(AF_INET, ip_s.back().c_str(), &addr) == 0)
        {
            std::cout << desc << std::endl;
            debugger.show_error_information("–û—à–∏–±–∫–∞ –≤ get_ip()", "ip –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç—É ipv4", "–õ–æ–≥–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞");
            return "";
        }

        return ip_s.back();
    }
    else
    {
        // –ï—Å–ª–∏ IP –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω ‚Äî –≤—ã–≤–æ–¥–∏–º —Å–ø—Ä–∞–≤–∫—É –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
        std::cout << desc << std::endl;
        debugger.show_error_information("–û—à–∏–±–∫–∞ –≤ get_ip()", "–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ ip", "–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞");
        return "";
    }
}

================================================================================
// –§–∞–π–ª: UI/ui.h
================================================================================

#pragma once
#include <boost/program_options.hpp>
#include <boost/filesystem.hpp>
#include <iostream>
#include <string>
#include <vector>
#include <arpa/inet.h>
#include "show_error.h"
namespace po = boost::program_options;

class UI {
public:
    show_error debugger;
    po::options_description desc;
    po::variables_map vm;

    UI(int argc, char* argv[]);
    uint get_port();
    uint get_op();
    std::string check_path(std::string path, std::string function);
    std::string get_serv_ip();
    std::string get_username();
    std::string get_password();
    std::string get_in_file_location();
    std::string get_out_file_location();
    std::string get_user_data_location();
};


================================================================================
// –§–∞–π–ª: Logger/logger.cpp
================================================================================

#include "logger.h"
int logger::write_log( std::string log_loc,  std::string message) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ª–æ–≥-—Ñ–∞–π–ª –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –ø—É—Ç–∏
    if (!boost::filesystem::exists(log_loc)) {
        std::cerr << "–¢–∞–∫–æ–≥–æ –ª–æ–≥ —Ñ–∞–π–ª–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: " << log_loc << std::endl;
        throw critical_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –ª–æ–≥ —Ñ–∞–π–ª");
    }

    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –¥–æ—Å—Ç—É–ø –∫ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—é
    std::lock_guard<std::mutex> lock(mtx);

    // –û—Ç–∫—Ä—ã–≤–∞–µ–º —Ñ–∞–π–ª –¥–ª—è –¥–æ–∑–∞–ø–∏—Å–∏ –≤–Ω—É—Ç—Ä–∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π —Å–µ–∫—Ü–∏–∏
    std::ofstream log_file(log_loc, std::ios::app | std::ios::out);
    if (!log_file.is_open()) {
        std::cerr << "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –ª–æ–≥ —Ñ–∞–π–ª –¥–ª—è –∑–∞–ø–∏—Å–∏: " << log_loc << std::endl;
        throw critical_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –ª–æ–≥ —Ñ–∞–π–ª");
    }

    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –µ–≥–æ
    auto now = std::chrono::system_clock::now();
    std::time_t t = std::chrono::system_clock::to_time_t(now);
    std::string time_str = std::ctime(&t);
    if (!time_str.empty() && time_str.back() == '\n') {
        time_str.pop_back();
    }

    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤—Ä–µ–º—è –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ª–æ–≥-—Ñ–∞–π–ª
    log_file << time_str << " / " << message << '\n';
    log_file.flush();  // —Å–±—Ä–æ—Å –±—É—Ñ–µ—Ä–∞
    // –§–∞–π–ª –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–∫—Ä–æ–µ—Ç—Å—è –ø–æ –≤—ã—Ö–æ–¥—É –∏–∑ scope

    return 0;
}

================================================================================
// –§–∞–π–ª: Logger/logger.h
================================================================================

#pragma once
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <chrono>
#include <cstring>
#include "../Error/error.h"
#include <mutex>
#include <boost/filesystem.hpp>
class logger{
    public:
    std::ofstream log;
    std::mutex mtx;
    int write_log(std::string log_loc,std::string message);
};

================================================================================
// –§–∞–π–ª: Protocol/protocol.cpp
================================================================================

#include "protocol.h"
#include <random>
#include <sstream>

std::string MessageProtocol::build(const std::string& header,
                                   const std::string& clientID,
                                   int messageID,
                                   const std::string& messageBody) {
    return header + "|clientID:" + clientID +
           "|messageID:" + std::to_string(messageID) +
           "|message:" + messageBody+"\n";
}
MessageProtocol::ParsedMessage MessageProtocol::parse(const std::string& raw) {
    std::mutex mtx;
    mtx.lock();
    ParsedMessage result;
    size_t pos = 0;
    size_t next = raw.find('|');

    // Header
    if (next == std::string::npos)
        return result; // bad format
    result.header = raw.substr(0, next);
    pos = next + 1;

    // Fields
    while ((next = raw.find('|', pos)) != std::string::npos) {
        std::string part = raw.substr(pos, next - pos);
        if (part.rfind("clientID:", 0) == 0) {
            result.clientID = part.substr(9);
        } else if (part.rfind("messageID:", 0) == 0) {
            try {
                result.messageID = std::stoi(part.substr(10));
            } catch (...) {
                result.messageID = -1;
            }
        }
        pos = next + 1;
    }

    // Last part (message)
    std::string last = raw.substr(pos);
    if (last.rfind("message:", 0) == 0) {
        result.message = last.substr(8);
        result.message.pop_back();
    }
    mtx.unlock();
    return result;
}

int MessageProtocol::generateMessageID() {
    static std::mt19937 gen(std::random_device{}());
    static std::uniform_int_distribution<> dist(1, 32);
    return dist(gen);
}


================================================================================
// –§–∞–π–ª: Protocol/protocol.h
================================================================================

#pragma once
#include <string>
#include <mutex>
class MessageProtocol {
public:
    struct ParsedMessage {
        std::string header;
        std::string clientID;
        int messageID = -1;
        std::string message;
    };

    static std::string build(const std::string& header,
                             const std::string& clientID,
                             int messageID,
                             const std::string& messageBody);

    static ParsedMessage parse(const std::string& raw);
    static int generateMessageID();
};


================================================================================
// –§–∞–π–ª: Rsa/rsa_crypto.cpp
================================================================================

#include "rsa_crypto.h"

// –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –¥–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
#define OPENSSL_API_COMPAT 0x10100000L
#include <openssl/bn.h>
#include <openssl/evp.h>

#include <stdexcept>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <fstream>
#include <random>

// --- –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (—Å–∫—Ä—ã—Ç—ã –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è) ---
namespace {

// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç BIGNUM (–∏–∑ OpenSSL) –≤ –Ω–∞—à BigInt
BigInt bignumToBigInt(const BIGNUM* bn) {
    char* hex_str = BN_bn2hex(bn);
    if (!hex_str) throw std::runtime_error("BN_bn2hex failed");

    std::string hex(hex_str);
    OPENSSL_free(hex_str);

    BigInt target;
    target.limbs.clear();
    if (hex.empty() || hex == "0") {
        return BigInt(0);
    }
    
    if (hex.size() % 16 != 0) {
        hex.insert(0, 16 - (hex.size() % 16), '0');
    }

    for (size_t i = 0; i < hex.size(); i += 16) {
        std::string part = hex.substr(i, 16);
        target.limbs.insert(target.limbs.begin(), std::stoull(part, nullptr, 16));
    }
    target.normalize();
    return target;
}

// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –Ω–∞—à BigInt –≤ BIGNUM (–∏–∑ OpenSSL)
// –í–∞–∂–Ω–æ: –≤—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥ –¥–æ–ª–∂–µ–Ω –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–∞–º—è—Ç—å —Å –ø–æ–º–æ—â—å—é BN_free()
BIGNUM* bigIntToBignum(const BigInt& bi) {
    BIGNUM* bn = nullptr;
    std::string hex = bi.toHexString();
    BN_hex2bn(&bn, hex.c_str());
    return bn;
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–æ—Å—Ç–æ—Ç—É —Å –ø–æ–º–æ—â—å—é OpenSSL
bool isPrime(const BigInt& candidate, int rounds = 64) {
    BIGNUM* bn = bigIntToBignum(candidate);
    BN_CTX* ctx = BN_CTX_new();
    int result = BN_is_prime_ex(bn, rounds, ctx, nullptr);
    BN_free(bn);
    BN_CTX_free(ctx);

    if (result < 0) throw std::runtime_error("Primality test error");
    return result == 1;
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ –≤ –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞
BigInt generatePrimeCandidate(size_t len) {
    if (len < 2) return BigInt(0);
    size_t limbCount = (len + 63) / 64;

    std::random_device rd;
    std::mt19937_64 gen(rd());
    std::uniform_int_distribution<uint64_t> dis;

    BigInt result;
    result.limbs.resize(limbCount, 0);
    for (size_t i = 0; i < limbCount; i++) {
        result.limbs[i] = dis(gen);
    }
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—à–∏–π –±–∏—Ç, —á—Ç–æ–±—ã —á–∏—Å–ª–æ –∏–º–µ–ª–æ –Ω—É–∂–Ω—É—é –¥–ª–∏–Ω—É
    result.limbs.back() |= (1ULL << ((len - 1) % 64));
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–ª–∞–¥—à–∏–π –±–∏—Ç, —á—Ç–æ–±—ã —á–∏—Å–ª–æ –±—ã–ª–æ –Ω–µ—á–µ—Ç–Ω—ã–º
    result.limbs[0] |= 1ULL;

    result.normalize();
    return result;
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞
BigInt generatePrime(size_t bitLength, int rounds) {
    while (true) {
        BigInt candidate = generatePrimeCandidate(bitLength);
        if (isPrime(candidate, rounds)) {
            return candidate;
        }
    }
}

} // –∫–æ–Ω–µ—Ü –∞–Ω–æ–Ω–∏–º–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –∏–º–µ–Ω

// --- –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–≤ BigInt ---

BigInt::BigInt() : limbs{0} {}
BigInt::BigInt(uint64_t value) {
    if (value == 0) limbs.push_back(0);
    else limbs.push_back(value);
}

void BigInt::normalize() {
    while (limbs.size() > 1 && limbs.back() == 0) {
        limbs.pop_back();
    }
}

bool BigInt::isZero() const {
    return limbs.size() == 1 && limbs[0] == 0;
}

std::string BigInt::toHexString() const {
    if (isZero()) return "0";
    std::ostringstream oss;
    oss << std::hex << std::uppercase;
    oss << limbs.back();
    for (int i = limbs.size() - 2; i >= 0; --i) {
        oss << std::setw(16) << std::setfill('0') << limbs[i];
    }
    return oss.str();
}

void BigInt::printHex(const std::string& label) const {
    if (!label.empty()) std::cout << label;
    std::cout << "0x" << this->toHexString() << std::dec << std::endl;
}


// --- –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–≤ RSAKeyPair ---

RSAKeyPair::RSAKeyPair(size_t bitLength) {
    std::cout << "üß™ Generating p..." << std::endl;
    p = generatePrime(bitLength / 2, 64);
    std::cout << "üß™ Generating q..." << std::endl;
    q = generatePrime(bitLength / 2, 64);

    BN_CTX* ctx = BN_CTX_new();
    BIGNUM* bn_p = bigIntToBignum(p);
    BIGNUM* bn_q = bigIntToBignum(q);
    
    // n = p * q
    BIGNUM* bn_n = BN_new();
    BN_mul(bn_n, bn_p, bn_q, ctx);
    n = bignumToBigInt(bn_n);

    // phi = (p-1)*(q-1)
    BIGNUM* bn_p1 = BN_dup(bn_p);
    BN_sub_word(bn_p1, 1);
    BIGNUM* bn_q1 = BN_dup(bn_q);
    BN_sub_word(bn_q1, 1);
    BIGNUM* bn_phi = BN_new();
    BN_mul(bn_phi, bn_p1, bn_q1, ctx);
    phi = bignumToBigInt(bn_phi);

    // e = 65537
    e = BigInt(65537);
    BIGNUM* bn_e = bigIntToBignum(e);

    // d = e^(-1) mod phi
    BIGNUM* bn_d = BN_mod_inverse(nullptr, bn_e, bn_phi, ctx);
    d = bignumToBigInt(bn_d);

    // –û—á–∏—Å—Ç–∫–∞
    BN_CTX_free(ctx);
    BN_free(bn_p); BN_free(bn_q); BN_free(bn_n);
    BN_free(bn_p1); BN_free(bn_q1); BN_free(bn_phi);
    BN_free(bn_e); BN_free(bn_d);
}

void RSAKeyPair::print() const {
    p.printHex("p: ");
    q.printHex("q: ");
    n.printHex("n (modulus): ");
    phi.printHex("phi: ");
    e.printHex("e (public exponent): ");
    d.printHex("d (private exponent): ");
}

// --- –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ç–¥–µ–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π ---

void saveKeyToFile(const std::string& filename, const BigInt& key) {
    std::ofstream out(filename, std::ios::binary);
    if (!out) throw std::runtime_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª –¥–ª—è –∑–∞–ø–∏—Å–∏: " + filename);
    uint64_t size = key.limbs.size();
    out.write(reinterpret_cast<const char*>(&size), sizeof(size));
    out.write(reinterpret_cast<const char*>(key.limbs.data()), size * sizeof(Limb));
}

BigInt loadKeyFromFile(const std::string& filename) {
    std::ifstream in(filename, std::ios::binary);
    if (!in) throw std::runtime_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª –¥–ª—è —á—Ç–µ–Ω–∏—è: " + filename);
    uint64_t size = 0;
    in.read(reinterpret_cast<char*>(&size), sizeof(size));
    if (!in || size == 0) throw std::runtime_error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞: " + filename);
    BigInt key;
    key.limbs.resize(size);
    in.read(reinterpret_cast<char*>(key.limbs.data()), size * sizeof(Limb));
    if (!in) throw std::runtime_error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –∫–ª—é—á–∞ –∏–∑ —Ñ–∞–π–ª–∞: " + filename);
    return key;
}

std::vector<unsigned char> sha256_hash_file(const std::string& filename) {
    std::ifstream file(filename, std::ios::binary);
    if (!file) throw std::runtime_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª: " + filename);

    EVP_MD_CTX* mdctx = EVP_MD_CTX_new();
    if (!mdctx) throw std::runtime_error("–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ EVP");
    if (1 != EVP_DigestInit_ex(mdctx, EVP_sha256(), nullptr)) {
        EVP_MD_CTX_free(mdctx);
        throw std::runtime_error("–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è");
    }

    const size_t bufSize = 4096;
    std::vector<char> buffer(bufSize);
    while (file) {
        file.read(buffer.data(), bufSize);
        if (file.gcount() > 0) {
            if (1 != EVP_DigestUpdate(mdctx, buffer.data(), file.gcount())) {
                EVP_MD_CTX_free(mdctx);
                throw std::runtime_error("–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ö–µ—à–∞");
            }
        }
    }

    std::vector<unsigned char> hash(EVP_MAX_MD_SIZE);
    unsigned int hash_len = 0;
    if (1 != EVP_DigestFinal_ex(mdctx, hash.data(), &hash_len)) {
        EVP_MD_CTX_free(mdctx);
        throw std::runtime_error("–û—à–∏–±–∫–∞ —Ñ–∏–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ —Ö–µ—à–∞");
    }
    hash.resize(hash_len);
    EVP_MD_CTX_free(mdctx);
    return hash;
}

BigInt rsa_mod_exp(const BigInt& base, const BigInt& exponent, const BigInt& modulus) {
    BN_CTX* ctx = BN_CTX_new();
    BIGNUM* bn_base = bigIntToBignum(base);
    BIGNUM* bn_exp = bigIntToBignum(exponent);
    BIGNUM* bn_mod = bigIntToBignum(modulus);
    BIGNUM* bn_res = BN_new();
    
    BN_mod_exp(bn_res, bn_base, bn_exp, bn_mod, ctx);
    
    BigInt result = bignumToBigInt(bn_res);

    BN_CTX_free(ctx);
    BN_free(bn_base); BN_free(bn_exp); BN_free(bn_mod); BN_free(bn_res);
    return result;
}

BigInt fromBytes(const std::vector<unsigned char>& bytes) {
    BIGNUM* bn = BN_bin2bn(bytes.data(), bytes.size(), nullptr);
    if (!bn) throw std::runtime_error("–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –±–∞–π—Ç–æ–≤ –≤ BigInt");
    BigInt result = bignumToBigInt(bn);
    BN_free(bn);
    return result;
}
std::vector<unsigned char> hexStringToBytes(const std::string& hex) {
    // –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é, —á—Ç–æ–±—ã –Ω–µ –∏–∑–º–µ–Ω—è—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª, –∏ —É–±–∏—Ä–∞–µ–º –ø—Ä–µ—Ñ–∏–∫—Å "0x", –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
    std::string processedHex = hex;
    if (processedHex.rfind("0x", 0) == 0 || processedHex.rfind("0X", 0) == 0) {
        processedHex = processedHex.substr(2);
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏ —á–µ—Ç–Ω–∞—è. –ö–∞–∂–¥—ã–π –±–∞–π—Ç –∫–æ–¥–∏—Ä—É–µ—Ç—Å—è –¥–≤—É–º—è HEX-—Å–∏–º–≤–æ–ª–∞–º–∏.
    if (processedHex.length() % 2 != 0) {
        throw std::invalid_argument("–®–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å —á–µ—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–º–≤–æ–ª–æ–≤.");
    }

    std::vector<unsigned char> bytes;
    // –†–µ–∑–µ—Ä–≤–∏—Ä—É–µ–º –ø–∞–º—è—Ç—å –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    bytes.reserve(processedHex.length() / 2);

    for (size_t i = 0; i < processedHex.length(); i += 2) {
        // –ë–µ—Ä–µ–º –¥–≤–∞ —Å–∏–º–≤–æ–ª–∞ (–æ–¥–∏–Ω –±–∞–π—Ç)
        std::string byteString = processedHex.substr(i, 2);
        try {
            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –¥–≤–∞ HEX-—Å–∏–º–≤–æ–ª–∞ –≤ —á–∏—Å–ª–æ –∏ –¥–æ–±–∞–≤–ª—è–µ–º –≤ –≤–µ–∫—Ç–æ—Ä
            unsigned char byte = static_cast<unsigned char>(std::stoul(byteString, nullptr, 16));
            bytes.push_back(byte);
        } catch (const std::exception& e) {
            throw std::invalid_argument("–°—Ç—Ä–æ–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã: '" + byteString + "'");
        }
    }

    return bytes;
}
BigInt BigInt::fromHexString(const std::string& hexString) {
    BIGNUM* bn = nullptr;
    std::string processedHex = hexString;
    // –£–¥–∞–ª—è–µ–º –ø—Ä–µ—Ñ–∏–∫—Å "0x" –∏–ª–∏ "0X", –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
    if (processedHex.rfind("0x", 0) == 0 || processedHex.rfind("0X", 0) == 0) {
        processedHex = processedHex.substr(2);
    }
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—É—é —Å—Ç—Ä–æ–∫—É –≤ OpenSSL BIGNUM
    // BN_hex2bn –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 0 –ø—Ä–∏ –æ—à–∏–±–∫–µ, 1 –ø—Ä–∏ —É—Å–ø–µ—Ö–µ.
    if (!BN_hex2bn(&bn, processedHex.c_str())) {
        if (bn) BN_free(bn); // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º, –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ –±—ã–ª–æ –≤—ã–¥–µ–ª–µ–Ω–æ –¥–æ –æ—à–∏–±–∫–∏
        throw std::runtime_error("Failed to convert hexadecimal string to BIGNUM: " + processedHex);
    }
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º OpenSSL BIGNUM –≤ –Ω–∞—à BigInt
    BigInt result = bignumToBigInt(bn);
    
    // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–∞–º—è—Ç—å, –≤—ã–¥–µ–ª–µ–Ω–Ω—É—é OpenSSL –¥–ª—è BIGNUM
    BN_free(bn);
    
    return result;
}

================================================================================
// –§–∞–π–ª: Rsa/rsa_crypto.h
================================================================================

#ifndef RSA_CRYPTO_H
#define RSA_CRYPTO_H

#include <string>
#include <vector>
#include <cstdint>

// –¢–∏–ø –¥–ª—è "–∫–æ–Ω–µ—á–Ω–æ—Å—Ç–µ–π" –±–æ–ª—å—à–æ–≥–æ —á–∏—Å–ª–∞
using Limb = uint64_t;

/**
 * @brief –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ –±–æ–ª—å—à–∏—Ö —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª.
 */
struct BigInt
{
    std::vector<Limb> limbs; // –•—Ä–∞–Ω—è—Ç—Å—è –≤ little-endian (–º–ª–∞–¥—à–∞—è —á–∞—Å—Ç—å –≤ –Ω–∞—á–∞–ª–µ)

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    BigInt();
    BigInt(uint64_t value);

    // –ú–µ—Ç–æ–¥—ã
    void normalize(); // –£–¥–∞–ª—è–µ—Ç –≤–µ–¥—É—â–∏–µ –Ω—É–ª–∏
    bool isZero() const;
    void printHex(const std::string &label = "") const;
    std::string toHexString() const;
    static BigInt fromHexString(const std::string& hexString);
};

/**
 * @brief –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–∞—Ä—ã –∫–ª—é—á–µ–π RSA.
 */
struct RSAKeyPair
{
    BigInt p, q, n, phi, e, d;

    /**
     * @brief –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –Ω–æ–≤—É—é –ø–∞—Ä—É –∫–ª—é—á–µ–π RSA –∑–∞–¥–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã.
     * @param bitLength –î–ª–∏–Ω–∞ –∫–ª—é—á–∞ –≤ –±–∏—Ç–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, 2048).
     */
    RSAKeyPair(size_t bitLength);

    /**
     * @brief –í—ã–≤–æ–¥–∏—Ç –≤—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∫–ª—é—á–µ–π –≤ –∫–æ–Ω—Å–æ–ª—å.
     */
    void print() const;
};

// --- –û—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –º–æ–¥—É–ª—è ---

/**
 * @brief –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–ª—é—á (BigInt) –≤ –±–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª.
 * @param filename –ò–º—è —Ñ–∞–π–ª–∞.
 * @param key –ö–ª—é—á –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è.
 */
void saveKeyToFile(const std::string &filename, const BigInt &key);

/**
 * @brief –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∫–ª—é—á (BigInt) –∏–∑ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ —Ñ–∞–π–ª–∞.
 * @param filename –ò–º—è —Ñ–∞–π–ª–∞.
 * @return –ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π –∫–ª—é—á —Ç–∏–ø–∞ BigInt.
 */
BigInt loadKeyFromFile(const std::string &filename);

/**
 * @brief –í—ã—á–∏—Å–ª—è–µ—Ç —Ö–µ—à SHA-256 –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞.
 * @param filename –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É.
 * @return –í–µ–∫—Ç–æ—Ä –±–∞–π—Ç, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∏–π —Ö–µ—à.
 */
std::vector<unsigned char> sha256_hash_file(const std::string &filename);

/**
 * @brief –í—ã–ø–æ–ª–Ω—è–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏—é –º–æ–¥—É–ª—å–Ω–æ–≥–æ –≤–æ–∑–≤–µ–¥–µ–Ω–∏—è –≤ —Å—Ç–µ–ø–µ–Ω—å (–æ—Å–Ω–æ–≤–∞^—ç–∫—Å–ø–æ–Ω–µ–Ω—Ç–∞ % –º–æ–¥—É–ª—å).
 * –≠—Ç–æ –æ—Å–Ω–æ–≤–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –∏ –ø–æ–¥–ø–∏—Å–∏ –≤ RSA.
 * @param base –û—Å–Ω–æ–≤–∞–Ω–∏–µ.
 * @param exponent –≠–∫—Å–ø–æ–Ω–µ–Ω—Ç–∞ (—Å—Ç–µ–ø–µ–Ω—å).
 * @param modulus –ú–æ–¥—É–ª—å.
 * @return –†–µ–∑—É–ª—å—Ç–∞—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏ (BigInt).
 */
BigInt rsa_mod_exp(const BigInt &base, const BigInt &exponent, const BigInt &modulus);

/**
 * @brief –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –≤–µ–∫—Ç–æ—Ä –±–∞–π—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ö–µ—à) –≤ BigInt.
 * @param bytes –í—Ö–æ–¥–Ω–æ–π –≤–µ–∫—Ç–æ—Ä –±–∞–π—Ç.
 * @return –û–±—ä–µ–∫—Ç BigInt.
 */
BigInt fromBytes(const std::vector<unsigned char> &bytes);
std::vector<unsigned char> hexStringToBytes(const std::string &hexString);
#endif // RSA_CRYPTO_H

