================================================================================
// –§–∞–π–ª: main.cpp
================================================================================

// –§–∞–π–ª: main.cpp
#include "UI/ui.h" // –í–ê–® –∫–ª–∞—Å—Å UI
#include "App_logic/AppLogic.h"
#include "Error/error.h" 
#include "Logger/logger.h" // –ù—É–∂–Ω–æ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–≥–≥–µ—Ä–∞
#include <iostream>
#include <memory>

int main(int argc, char* argv[]) {
    try {
        // –®–∞–≥ 1: –°–æ–∑–¥–∞–µ–º –í–ê–® –æ–±—ä–µ–∫—Ç UI –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤.
        UI cmd_line_interface(argc, argv);

        // –®–∞–≥ 2: –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–∑ –Ω–µ–≥–æ –≤—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∞–Ω–Ω—ã–µ
        std::string ip = cmd_line_interface.get_serv_ip();
        uint16_t port = cmd_line_interface.get_port();
        std::string username = cmd_line_interface.get_username();
        std::string password = cmd_line_interface.get_password();
        uint operation_code = cmd_line_interface.get_op();

        // –®–∞–≥ 3: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –æ–±—â–∏–º–∏
        // –ù–∞–ø—Ä–∏–º–µ—Ä, –ª–æ–≥–≥–µ—Ä. –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ —É –≤–∞—Å –µ—Å—Ç—å —Å–ø–æ—Å–æ–± –ø–æ–ª—É—á–∏—Ç—å –ø—É—Ç—å –∫ –ª–æ–≥–∞–º,
        // –∏–ª–∏ –∑–∞–¥–∞–¥–∏–º –µ–≥–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.
        // !!!–í–ê–ñ–ù–û!!!: –£ –≤–∞—Å –≤ –∫–ª–∞—Å—Å–µ UI –Ω–µ—Ç –º–µ—Ç–æ–¥–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø—É—Ç–∏ –∫ –ª–æ–≥—É, 
        // —Ö–æ—Ç—è –≤ Logger –æ–Ω —Ç—Ä–µ–±—É–µ—Ç—Å—è. –î–∞–≤–∞–π—Ç–µ –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞—Ö–∞—Ä–¥–∫–æ–¥–∏–º –ø—É—Ç—å.
        std::string log_file_path = "client_log.txt"; 
        // –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —ç—Ç–æ—Ç —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –∏–Ω–∞—á–µ –≤–∞—à –ª–æ–≥–≥–µ—Ä –±—Ä–æ—Å–∏—Ç –∏—Å–∫–ª—é—á–µ–Ω–∏–µ!
        std::shared_ptr<logger> app_logger = std::make_shared<logger>();

        // –®–∞–≥ 4: –°–æ–∑–¥–∞–µ–º –≥–ª–∞–≤–Ω—ã–π –ª–æ–≥–∏—á–µ—Å–∫–∏–π –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä
        AppLogic application(ip, port, username, password, app_logger, log_file_path);

        // –®–∞–≥ 5: –í–´–ë–ò–†–ê–ï–ú –ò –ó–ê–ü–£–°–ö–ê–ï–ú –ù–£–ñ–ù–´–ô –°–¶–ï–ù–ê–†–ò–ô
        if (operation_code == 1) {
            // –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
            application.run_login_flow();
        } else if (operation_code == 0) {
            // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
            application.run_registration_flow();
        } else {
            // –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π, —Ö–æ—Ç—è get_op —É–∂–µ –¥–æ–ª–∂–µ–Ω –±—ã–ª –±—Ä–æ—Å–∏—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ
            std::cerr << "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–æ–¥ –æ–ø–µ—Ä–∞—Ü–∏–∏." << std::endl;
        }

    } catch (const po::error& e) {
        std::cerr << "–û—à–∏–±–∫–∞ –≤ –∞—Ä–≥—É–º–µ–Ω—Ç–∞—Ö –∑–∞–ø—É—Å–∫–∞: " << e.what() << std::endl;
        return 1;
    } catch (const critical_error& e) {
        std::cerr << "–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: " << e.what() << std::endl;
        return 1;
    } catch (const std::exception& e) {
        std::cerr << "–ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}

================================================================================
// –§–∞–π–ª: Protocol_utils/protocol_utils.cpp
================================================================================

// –§–∞–π–ª: Protocol_utils/protocol_utils.cpp (–ù–û–í–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø)

#include "protocol_utils.h"

// –ù–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Å–∏—Å—Ç–µ–º–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–æ—á–Ω—ã–µ —Ñ–∞–π–ª—ã
#include <sys/socket.h>
#include <unistd.h>
#include <vector>
#include <iostream>
#include <arpa/inet.h> // –î–ª—è htonl, ntohl
#include <stdexcept>

namespace ProtocolUtils {

    // --- –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (–æ–Ω–∏ —Ç–µ–ø–µ—Ä—å –æ—Å–Ω–æ–≤–∞) ---
    namespace {

        /**
         * @brief –ù–∞–¥–µ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –≤–µ—Å—å –±—É—Ñ–µ—Ä –¥–∞–Ω–Ω—ã—Ö –≤ —Å–æ–∫–µ—Ç.
         */
        int send_all(int socket, const char* buffer, size_t length) {
            size_t total_sent = 0;
            while (total_sent < length) {
                ssize_t sent_now = ::send(socket, buffer + total_sent, length - total_sent, MSG_NOSIGNAL);
                if (sent_now <= 0) {
                    perror("send_all failed");
                    return -1; // –û—à–∏–±–∫–∞ –∏–ª–∏ —Ä–∞–∑—Ä—ã–≤ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
                }
                total_sent += sent_now;
            }
            return 0; // –£—Å–ø–µ—Ö
        }

        /**
         * @brief –ù–∞–¥–µ–∂–Ω–æ —á–∏—Ç–∞–µ—Ç —Ä–æ–≤–Ω–æ `bytes_to_receive` –±–∞–π—Ç –∏–∑ —Å–æ–∫–µ—Ç–∞.
         * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç MSG_WAITALL –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏.
         * @return –°—Ç—Ä–æ–∫–∞ —Å –¥–∞–Ω–Ω—ã–º–∏ –∏–ª–∏ –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ/—Ä–∞–∑—Ä—ã–≤–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è.
         */
        std::string receive_all(int socket, size_t bytes_to_receive) {
            if (bytes_to_receive == 0) return "";
            
            std::string buffer(bytes_to_receive, '\0');
            ssize_t bytes_read = ::recv(socket, &buffer[0], bytes_to_receive, MSG_WAITALL);
            
            if (bytes_read != static_cast<ssize_t>(bytes_to_receive)) {
                // –ï—Å–ª–∏ –º—ã –Ω–µ –ø–æ–ª—É—á–∏–ª–∏ —Ä–æ–≤–Ω–æ —Å—Ç–æ–ª—å–∫–æ, —Å–∫–æ–ª—å–∫–æ –ø—Ä–æ—Å–∏–ª–∏, —ç—Ç–æ –æ—à–∏–±–∫–∞ –∏–ª–∏ —Ä–∞–∑—Ä—ã–≤.
                return "";
            }
            
            return buffer;
        }

    } // –∫–æ–Ω–µ—Ü –∞–Ω–æ–Ω–∏–º–Ω–æ–≥–æ namespace

    // --- –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø—É–±–ª–∏—á–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π —Å –ù–û–í–û–ô –ª–æ–≥–∏–∫–æ–π ---

    int send_formatted_message(int socket, const std::string& header, const std::string& client_id, int msg_id, const std::string& message) {
        // 1. –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–ª–æ —Å–æ–æ–±—â–µ–Ω–∏—è (–∫–∞–∫ –∏ —Ä–∞–Ω—å—à–µ)
        std::string body = MessageProtocol::build(header, client_id, msg_id, message);
        
        // 2. –ü–æ–ª—É—á–∞–µ–º –µ–≥–æ –¥–ª–∏–Ω—É –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ 4-–±–∞–π—Ç–æ–≤–æ–µ —Å–µ—Ç–µ–≤–æ–µ —á–∏—Å–ª–æ
        uint32_t len = body.length();
        uint32_t network_len = htonl(len); // Host-To-Network-Long
        
        // 3. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º 4 –±–∞–π—Ç–∞ —Å –¥–ª–∏–Ω–æ–π
        if (send_all(socket, reinterpret_cast<const char*>(&network_len), sizeof(network_len)) != 0) {
            std::cerr << "[ProtocolUtils] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–ª–∏–Ω—ã —Å–æ–æ–±—â–µ–Ω–∏—è." << std::endl;
            return -1;
        }

        // 4. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∞–º–æ —Ç–µ–ª–æ —Å–æ–æ–±—â–µ–Ω–∏—è
        if (send_all(socket, body.data(), body.size()) != 0) {
            std::cerr << "[ProtocolUtils] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ç–µ–ª–∞ —Å–æ–æ–±—â–µ–Ω–∏—è." << std::endl;
            return -1;
        }

        return 0; // –£—Å–ø–µ—Ö
    }
    

    std::optional<MessageProtocol::ParsedMessage> receive_and_parse_message(int socket) {
        // 1. –ß–∏—Ç–∞–µ–º —Ä–æ–≤–Ω–æ 4 –±–∞–π—Ç–∞, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å –¥–ª–∏–Ω—É
        uint32_t network_len = 0;
        std::string len_bytes = receive_all(socket, sizeof(network_len));
        if (len_bytes.size() != sizeof(network_len)) {
            // –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ
            return std::nullopt;
        }
        network_len = *reinterpret_cast<const uint32_t*>(len_bytes.data());

        // 2. –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∏–∑ —Å–µ—Ç–µ–≤–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ –≤ —Ö–æ—Å—Ç–æ–≤—ã–π
        uint32_t body_len = ntohl(network_len);
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∞–¥–µ–∫–≤–∞—Ç–Ω–æ—Å—Ç—å —Ä–∞–∑–º–µ—Ä–∞ (–∑–∞—â–∏—Ç–∞ –æ—Ç DoS-–∞—Ç–∞–∫ —Å –æ–≥—Ä–æ–º–Ω—ã–º —Ä–∞–∑–º–µ—Ä–æ–º)
        const size_t MAX_MSG_SIZE = 1024 * 1024; // 1 MB, –Ω–∞–ø—Ä–∏–º–µ—Ä
        if (body_len > MAX_MSG_SIZE) {
            std::cerr << "[ProtocolUtils] –û—à–∏–±–∫–∞: –ø–æ–ª—É—á–µ–Ω–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è –¥–ª–∏–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è: " << body_len << std::endl;
            return std::nullopt;
        }

        // 3. –ß–∏—Ç–∞–µ–º —Ä–æ–≤–Ω–æ `body_len` –±–∞–π—Ç —Ç–µ–ª–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
        std::string body = receive_all(socket, body_len);
        if (body.size() != body_len) {
            // –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ç–µ–ª–∞
            return std::nullopt;
        }

        // 4. –ü–∞—Ä—Å–∏–º —Ç–µ–ª–æ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º
        try {
            return MessageProtocol::parse(body);
        } catch (const std::exception& e) {
            std::cerr << "[ProtocolUtils] –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Ç–µ–ª–∞ —Å–æ–æ–±—â–µ–Ω–∏—è: " << e.what() << std::endl;
            return std::nullopt;
        }
    }

} // namespace ProtocolUtils

================================================================================
// –§–∞–π–ª: Protocol_utils/protocol_utils.h
================================================================================

// –§–∞–π–ª: Protocol_utils/protocol_utils.h (–æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
#pragma once

#include <string>
#include <optional>
#include "../Protocol/protocol.h" 

namespace ProtocolUtils {

    /**
     * @brief –í—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ –ø—Ä–æ—Ç–æ–∫–æ–ª—É.
     * @details (–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç 4 –±–∞–π—Ç–∞ –¥–ª–∏–Ω—ã + —Ç–µ–ª–æ).
     * @return 0 –≤ —Å–ª—É—á–∞–µ —É—Å–ø–µ—Ö–∞, -1 –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏.
     */
    int send_formatted_message(int socket, const std::string& header, const std::string& client_id, int msg_id, const std::string& message);

    /**
     * @brief –í—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–µ–º–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ –ø—Ä–æ—Ç–æ–∫–æ–ª—É.
     * @details (–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç 4 –±–∞–π—Ç–∞ –¥–ª–∏–Ω—ã + —Ç–µ–ª–æ).
     * @return –†–∞—Å–ø–∞—Ä—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ–ª–µ–∑–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞. std::nullopt –ø—Ä–∏ –æ—à–∏–±–∫–µ.
     */
    std::optional<MessageProtocol::ParsedMessage> receive_and_parse_message(int socket);

    // –°—Ç–∞—Ä—ã–µ send_packet/receive_packet –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å –∫–∞–∫ –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ –∏–ª–∏ —É–¥–∞–ª–∏—Ç—å,
    // –µ—Å–ª–∏ –æ–Ω–∏ –±–æ–ª—å—à–µ –Ω–∏–≥–¥–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é. –î–ª—è —á–∏—Å—Ç–æ—Ç—ã –ª—É—á—à–µ —É–±—Ä–∞—Ç—å.
}

================================================================================
// –§–∞–π–ª: Error/error.h
================================================================================

#pragma once
#include <stdexcept>
#include <string>
/** –ö–ª–∞—Å—Å –æ—à–∏–±–æ–∫
*  –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –æ—Ç–ª–æ–≤–∞ —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–æ–∫, –≤–æ–∑–Ω–∏–∫–∞—é—â–∏—Ö –≤ —Ö–æ–¥–µ —Ä–∞–±–æ—Ç—ã –º–æ–¥—É–ª–µ–π
*  –í –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è —Å—Ç—Ä–æ–∫–∞ —Å —Å–æ–æ–±—â–µ–Ω–∏–µ–º –æ—à–∏–±–∫–∏
*/
class critical_error:public std::runtime_error{
    public:
    /** –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –æ—à–∏–±–∫–∏
    * s –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
    */
    critical_error(const std::string& s):std::runtime_error(s){}
};

================================================================================
// –§–∞–π–ª: Service/SignatureService.cpp
================================================================================

// –§–∞–π–ª: Service/SignatureService.cpp
#include "SignatureService.h"

// --- –ù–ï–û–ë–•–û–î–ò–ú–´–ï –í–ö–õ–Æ–ß–ï–ù–ò–Ø ---
#include "../Crypto_utils/crypto_utils.h" // –¢–µ–ø–µ—Ä—å —ç—Ç–æ—Ç —Ñ–∞–π–ª –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ–ø—Ä–µ–¥–µ–ª–µ–Ω
#include "../Rsa/rsa_crypto.h"
#include <stdexcept>
#include <algorithm> // –¥–ª—è std::transform

// --- –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–≤ ---

std::string SignatureService::hash_file(const std::string& file_path) const {
    // –í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –Ω–∞—à–µ–≥–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é –≥–æ—Ç–æ–≤–æ–≥–æ –º–æ–¥—É–ª—è
    return CryptoUtils::generate_hash_from_file(file_path);
}

void SignatureService::save_signature(const std::string& original_file_path, const std::string& signature_hex) const {
    // 1. –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º HEX-—Å—Ç—Ä–æ–∫—É –ø–æ–¥–ø–∏—Å–∏ –≤ –æ–±—ä–µ–∫—Ç BigInt
    BigInt signature_as_bigint = BigInt::fromHexString(signature_hex);
    
    // 2. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –¥–ª—è –ø–æ–¥–ø–∏—Å–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, document.txt -> document.txt.sig)
    std::string signature_filename = original_file_path + ".sig";
    
    // 3. –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–∞—à—É —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
    // `saveKeyToFile` –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ `Rsa/rsa_crypto.cpp`.
    saveKeyToFile(signature_filename, signature_as_bigint);
}

bool SignatureService::verify_signature(
    const std::string& original_file_path,
    const std::string& signature_file_path,
    const BigInt& public_n, 
    const BigInt& public_e
) const {
    try {
        // --- –®–∞–≥ 1: –í—ã—á–∏—Å–ª—è–µ–º —Ö–µ—à –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ ---
        std::string original_hash_hex = this->hash_file(original_file_path);
        
        // --- –®–∞–≥ 2: –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–æ–¥–ø–∏—Å—å –∏–∑ —Ñ–∞–π–ª–∞ ---
        // `loadKeyFromFile` –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ `Rsa/rsa_crypto.cpp`
        BigInt signature_as_bigint = loadKeyFromFile(signature_file_path);
        
        // --- –®–∞–≥ 3: –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º –ø–æ–¥–ø–∏—Å—å –ø—É–±–ª–∏—á–Ω—ã–º –∫–ª—é—á–æ–º ---
        // `rsa_mod_exp` –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ `Rsa/rsa_crypto.cpp`
        BigInt decrypted_hash_bigint = rsa_mod_exp(signature_as_bigint, public_e, public_n);
        
        // --- –®–∞–≥ 4: –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –æ–±–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤ HEX-—Å—Ç—Ä–æ–∫–∏ –∏ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º ---
        std::string decrypted_hash_hex = decrypted_hash_bigint.toHexString();
        
        // –ü—Ä–∏–≤–æ–¥–∏–º –æ–±–µ —Å—Ç—Ä–æ–∫–∏ –∫ –≤–µ—Ä—Ö–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
        std::transform(original_hash_hex.begin(), original_hash_hex.end(), original_hash_hex.begin(), ::toupper);
        std::transform(decrypted_hash_hex.begin(), decrypted_hash_hex.end(), decrypted_hash_hex.begin(), ::toupper);
        
        return original_hash_hex == decrypted_hash_hex;

    } catch (const std::exception& e) {
        // –ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º –æ—à–∏–±–∫–∏ –æ—Ç –Ω–∏–∂–Ω–∏—Ö —É—Ä–æ–≤–Ω–µ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, "—Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω")
        // –∏ –ø–µ—Ä–µ–¥–∞–µ–º –∏—Ö –Ω–∞–≤–µ—Ä—Ö –≤ –≤–∏–¥–µ –æ–¥–Ω–æ–≥–æ –ø–æ–Ω—è—Ç–Ω–æ–≥–æ –∏—Å–∫–ª—é—á–µ–Ω–∏—è.
        throw std::runtime_error("–û—à–∏–±–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏: " + std::string(e.what()));
    }
}

================================================================================
// –§–∞–π–ª: Service/SignatureService.h
================================================================================

#pragma once
#include <string>
#include "../Rsa/rsa_crypto.h" 
class SignatureService {
public:
    std::string hash_file(const std::string& file_path) const;
    void save_signature(const std::string& original_file_path, const std::string& signature_hex) const;
    bool verify_signature(
        const std::string& original_file_path,
        const std::string& signature_file_path,
        const BigInt& public_n, 
        const BigInt& public_e
    ) const;
};

================================================================================
// –§–∞–π–ª: Crypto_utils/crypto_utils.cpp
================================================================================

// –§–∞–π–ª: Crypto_utils/crypto_utils.cpp
#include "crypto_utils.h"

// --- –ó–∞–≥–æ–ª–æ–≤–æ—á–Ω—ã–µ —Ñ–∞–π–ª—ã Crypto++ ---
#include <cryptopp/sha.h>
#include <cryptopp/osrng.h> 
#include <cryptopp/filters.h>
#include <cryptopp/hex.h>
#include <cryptopp/secblock.h>
#include <cryptopp/files.h> // <-- –í–∞–∂–Ω—ã–π –∏–Ω–∫–ª—é–¥ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏
#include <stdexcept>

namespace CryptoUtils {

// --- generate_hash –∏ generate_random_hex_string –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ---

std::string generate_hash(const std::string& input) {
    CryptoPP::SHA256 hash_algorithm;
    std::string digest;
    CryptoPP::StringSource(input, true, 
        new CryptoPP::HashFilter(hash_algorithm,
            new CryptoPP::HexEncoder(
                new CryptoPP::StringSink(digest)
            )
        )
    );
    return digest;
}

std::string generate_random_hex_string(size_t byte_length) {
    CryptoPP::AutoSeededRandomPool prng;
    CryptoPP::SecByteBlock random_bytes(byte_length);
    prng.GenerateBlock(random_bytes, random_bytes.size());

    std::string hex_encoded_string;
    CryptoPP::StringSource(random_bytes, random_bytes.size(), true,
        new CryptoPP::HexEncoder(
            new CryptoPP::StringSink(hex_encoded_string)
        )
    );
    return hex_encoded_string;
}

// --- –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è (–ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–Ω–∞—è –∏–∑ –≤–∞—à–µ–≥–æ —Å—Ç–∞—Ä–æ–≥–æ client.cpp) ---

std::string generate_hash_from_file(const std::string& file_path) {
    try {
        CryptoPP::SHA256 hash;
        std::string digest;

        // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω–≤–µ–π–µ—Ä: –∏—Å—Ç–æ—á–Ω–∏–∫ –∏–∑ —Ñ–∞–π–ª–∞ -> —Ö–µ—à-—Ñ–∏–ª—å—Ç—Ä -> –∫–æ–¥–∏—Ä–æ–≤—â–∏–∫ –≤ HEX -> –ø—Ä–∏–µ–º–Ω–∏–∫-—Å—Ç—Ä–æ–∫–∞.
        CryptoPP::FileSource file(file_path.c_str(), true, 
            new CryptoPP::HashFilter(hash,
                new CryptoPP::HexEncoder(
                    new CryptoPP::StringSink(digest)
                )
            )
        );
        return digest;

    } catch (const CryptoPP::FileStore::OpenErr& e) {
        // –ö–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏ "—Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω"
        throw std::runtime_error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Ñ–∞–π–ª–∞ –¥–ª—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è: " + file_path + ". " + e.what());
    } catch (const CryptoPP::Exception& e) {
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫ Crypto++
        throw std::runtime_error("–û—à–∏–±–∫–∞ Crypto++ –ø—Ä–∏ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞ " + file_path + ": " + e.what());
    }
}

} // namespace CryptoUtils

================================================================================
// –§–∞–π–ª: Crypto_utils/crypto_utils.h
================================================================================

// crypto_utils.h
#pragma once
#include <string>

namespace CryptoUtils {
    // –•–µ—à–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É —Å –ø–æ–º–æ—â—å—é SHA-256 –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç HEX
    std::string generate_hash(const std::string& input);

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫—Ä–∏–ø—Ç–æ-—Å—Ç–æ–π–∫—É—é —Å–ª—É—á–∞–π–Ω—É—é HEX-—Å—Ç—Ä–æ–∫—É
    std::string generate_random_hex_string(size_t byte_length);
    std::string generate_hash_from_file(const std::string& file_path);
}

================================================================================
// –§–∞–π–ª: UI/InteractiveConsole.cpp
================================================================================

// –§–∞–π–ª: UI/InteractiveConsole.cpp
#include "InteractiveConsole.h"
#include <iostream>
#include <limits> // –î–ª—è std::numeric_limits

// --- –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–≤ –≤—ã–≤–æ–¥–∞ ---

void InteractiveConsole::show_message(const std::string& msg) const {
    std::cout << "[INFO] " << msg << std::endl;
}

void InteractiveConsole::show_error(const std::string& err_msg) const {
    std::cerr << "[–û–®–ò–ë–ö–ê] " << err_msg << std::endl;
}


// --- –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–≤ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è ---

void InteractiveConsole::clear_input_buffer() const {
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
}

UserMenuChoice InteractiveConsole::get_user_menu_choice() const {
    std::cout << "\n========================================" << std::endl;
    std::cout << "  –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:" << std::endl;
    std::cout << "  1. –ó–∞–ø—Ä–æ—Å–∏—Ç—å –ø–æ–¥–ø–∏—Å—å –¥–ª—è —Ñ–∞–π–ª–∞" << std::endl;
    std::cout << "  2. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å—å –ª–æ–∫–∞–ª—å–Ω–æ" << std::endl;
    std::cout << "  0. –í—ã—Ö–æ–¥" << std::endl;
    std::cout << "========================================" << std::endl;
    std::cout << "–í–∞—à –≤—ã–±–æ—Ä -> ";

    int choice = -1;
    std::cin >> choice;

    // –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ –≤–≤–æ–¥ –±—ã–ª —á–∏—Å–ª–æ–º. –ï—Å–ª–∏ –Ω–µ—Ç, std::cin –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ—à–∏–±–∫–∏.
    if (std::cin.fail()) {
        std::cin.clear(); // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –æ—à–∏–±–∫–∏
        clear_input_buffer(); // –û—á–∏—â–∞–µ–º –±—É—Ñ–µ—Ä –æ—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –≤–≤–æ–¥–∞
        return UserMenuChoice::UNKNOWN;
    }
    
    // –û—á–∏—â–∞–µ–º –±—É—Ñ–µ—Ä –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è —á–∏—Å–ª–∞, —á—Ç–æ–±—ã —Å–ª–µ–¥—É—é—â–∏–π std::getline —Ä–∞–±–æ—Ç–∞–ª –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
    clear_input_buffer(); 

    switch (choice) {
        case 1: return UserMenuChoice::REQUEST_SIGNATURE;
        case 2: return UserMenuChoice::VERIFY_LOCALLY;
        case 0: return UserMenuChoice::EXIT;
        default: return UserMenuChoice::UNKNOWN;
    }
}

std::string InteractiveConsole::ask_filepath(const std::string& prompt) const {
    std::cout << "[–í–í–û–î] " << prompt;
    std::string file_path;
    std::getline(std::cin, file_path);
    
    // –ü—Ä–æ—Å—Ç–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞ –ø—É—Å—Ç–æ–π –≤–≤–æ–¥
    if (file_path.empty()) {
        show_error("–ü—É—Ç—å –∫ —Ñ–∞–π–ª—É –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.");
    }
    return file_path;
}

// --- –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–≤ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ ---

void InteractiveConsole::display_signature(const std::string& signature_hex) const {
    std::cout << "[–†–ï–ó–£–õ–¨–¢–ê–¢] –ü–æ–ª—É—á–µ–Ω–∞ –ø–æ–¥–ø–∏—Å—å –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞:" << std::endl;
    std::cout << "------------------------------------------" << std::endl;
    std::cout << signature_hex << std::endl;
    std::cout << "------------------------------------------" << std::endl;
}

void InteractiveConsole::display_verification_result(bool is_valid) const {
    std::cout << "[–†–ï–ó–£–õ–¨–¢–ê–¢ –ü–†–û–í–ï–†–ö–ò]" << std::endl;
    if (is_valid) {
        std::cout << "  –ü–û–î–ü–ò–°–¨ –í–ï–†–ù–ê: –•–µ—à–∏ —Å–æ–≤–ø–∞–¥–∞—é—Ç." << std::endl;
    } else {
        std::cout << "  –ü–û–î–ü–ò–°–¨ –ù–ï–í–ï–†–ù–ê: –•–µ—à–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç." << std::endl;
    }
}

================================================================================
// –§–∞–π–ª: UI/InteractiveConsole.h
================================================================================

#pragma once
#include <string>
enum class UserMenuChoice {
    REQUEST_SIGNATURE, // –ó–∞–ø—Ä–æ—Å–∏—Ç—å –ø–æ–¥–ø–∏—Å—å –¥–ª—è —Ñ–∞–π–ª–∞
    VERIFY_LOCALLY,    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å—å –ª–æ–∫–∞–ª—å–Ω–æ
    EXIT,              // –í—ã—Ö–æ–¥ –∏–∑ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    UNKNOWN            // –ù–µ–≤–µ—Ä–Ω—ã–π –≤–≤–æ–¥
};

class InteractiveConsole {
public:
    void show_message(const std::string& msg) const;
    void show_error(const std::string& err_msg) const;
    UserMenuChoice get_user_menu_choice() const;
    std::string ask_filepath(const std::string& prompt) const;
    void display_signature(const std::string& signature_hex) const;
    void display_verification_result(bool is_valid) const;
    
private:
    void clear_input_buffer() const;
};

================================================================================
// –§–∞–π–ª: UI/ui.cpp
================================================================================

// –§–∞–π–ª: UI/ui.cpp
#include "ui.h"
#include <iostream>
#include <stdexcept> // –¥–ª—è std::invalid_argument
#include <arpa/inet.h> // –¥–ª—è inet_pton

UI::UI(int argc, char* argv[]) : desc("–î–æ–ø—É—Å—Ç–∏–º—ã–µ –æ–ø—Ü–∏–∏") {
    // 1. –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ–ø—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç.
    // –≠—Ç–æ –≤–∑—è—Ç–æ –∏–∑ –≤–∞—à–µ–≥–æ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∫–æ–¥–∞.
    desc.add_options()
        ("help,h", "–ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ")
        ("serv_ip,s", po::value<std::string>(), "IP-–∞–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞")
        ("port,p", po::value<uint16_t>(), "–ü–æ—Ä—Ç —Å–µ—Ä–≤–µ—Ä–∞ (1024-65535)")
        ("operation,o", po::value<uint>(), "–ù–∞—á–∞–ª—å–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è: 0 (—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è) –∏–ª–∏ 1 (–∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è)")
        ("username,u", po::value<std::string>(), "–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
        ("password,x", po::value<std::string>(), "–ü–∞—Ä–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∏—Å–ø–æ–ª—å–∑—É–µ–º -x –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)");

    // 2. –ü–∞—Ä—Å–∏–Ω–≥. –õ—é–±—ã–µ –æ—à–∏–±–∫–∏ –∑–¥–µ—Å—å –±—É–¥—É—Ç –±—Ä–æ—à–µ–Ω—ã –∫–∞–∫ po::error –∏ –ø–æ–π–º–∞–Ω—ã –≤ main.cpp.
    po::store(po::parse_command_line(argc, argv, desc), vm);
    po::notify(vm);

    // 3. –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–ø—Ü–∏–∏ --help. –≠—Ç–æ —à—Ç–∞—Ç–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ, –∞ –Ω–µ –æ—à–∏–±–∫–∞.
    if (vm.count("help")) {
        std::cout << desc << std::endl;
        exit(0); // –ó–∞–≤–µ—Ä—à–∞–µ–º –ø—Ä–æ–≥—Ä–∞–º–º—É –ø–æ—Å–ª–µ –≤—ã–≤–æ–¥–∞ —Å–ø—Ä–∞–≤–∫–∏
    }
    
    // 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –≤—Å–µ—Ö –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤. –ï—Å–ª–∏ —á–µ–≥–æ-—Ç–æ –Ω–µ—Ç - –±—Ä–æ—Å–∞–µ–º –∏—Å–∫–ª—é—á–µ–Ω–∏–µ.
    if (!vm.count("serv_ip") || !vm.count("port") || !vm.count("operation") || !vm.count("username") || !vm.count("password")) {
         std::cout << desc << std::endl;
        throw critical_error("–ù–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –±—ã–ª–∏ —É–∫–∞–∑–∞–Ω—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ --help –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏.");
    }
}

std::string UI::get_serv_ip() const {
    const std::string ip_str = vm["serv_ip"].as<std::string>();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ IP-–∞–¥—Ä–µ—Å –∏–º–µ–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç IPv4
    struct sockaddr_in sa;
    if (inet_pton(AF_INET, ip_str.c_str(), &(sa.sin_addr)) != 1) {
        throw critical_error("–£–∫–∞–∑–∞–Ω–Ω—ã–π IP-–∞–¥—Ä–µ—Å '" + ip_str + "' –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º IPv4 –∞–¥—Ä–µ—Å–æ–º.");
    }
    return ip_str;
}

uint16_t UI::get_port() const {
    const uint16_t port = vm["port"].as<uint16_t>();
    if (port < 1024 || port > 65535) {
        throw critical_error("–ü–æ—Ä—Ç " + std::to_string(port) + " –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤–Ω–µ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ [1024-65535].");
    }
    return port;
}

std::string UI::get_username() const {
    // –ü—Ä–æ–≤–µ—Ä—è—Ç—å vm.count() –∑–¥–µ—Å—å —É–∂–µ –Ω–µ –Ω—É–∂–Ω–æ, —Ç–∞–∫ –∫–∞–∫ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —ç—Ç–æ —Å–¥–µ–ª–∞–ª.
    return vm["username"].as<std::string>();
}

std::string UI::get_password() const {
    return vm["password"].as<std::string>();
}

uint UI::get_op() const {
    const uint op_code = vm["operation"].as<uint>();
    if (op_code != 0 && op_code != 1) {
        throw critical_error("–ö–æ–¥ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 0 (—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è) –∏–ª–∏ 1 (–∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è), –Ω–æ –ø–æ–ª—É—á–µ–Ω: " + std::to_string(op_code));
    }
    return op_code;
}

================================================================================
// –§–∞–π–ª: UI/ui.h
================================================================================

#pragma once
#include <boost/program_options.hpp>
#include <string>
#include <vector>
#include <cstdint>
#include "../Error/error.h"
namespace po = boost::program_options;
class UI {
public:
    UI(int argc, char* argv[]);
    uint16_t get_port() const;
    std::string get_serv_ip() const;
    std::string get_username() const;
    std::string get_password() const;
    uint get_op() const;

private:
    po::options_description desc;
    po::variables_map vm;
};

================================================================================
// –§–∞–π–ª: Logger/logger.cpp
================================================================================

#include "logger.h"
int logger::write_log( std::string log_loc,  std::string message) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ª–æ–≥-—Ñ–∞–π–ª –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –ø—É—Ç–∏
    if (!boost::filesystem::exists(log_loc)) {
        std::cerr << "–¢–∞–∫–æ–≥–æ –ª–æ–≥ —Ñ–∞–π–ª–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: " << log_loc << std::endl;
        throw critical_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –ª–æ–≥ —Ñ–∞–π–ª");
    }

    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –¥–æ—Å—Ç—É–ø –∫ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—é
    std::lock_guard<std::mutex> lock(mtx);

    // –û—Ç–∫—Ä—ã–≤–∞–µ–º —Ñ–∞–π–ª –¥–ª—è –¥–æ–∑–∞–ø–∏—Å–∏ –≤–Ω—É—Ç—Ä–∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π —Å–µ–∫—Ü–∏–∏
    std::ofstream log_file(log_loc, std::ios::app | std::ios::out);
    if (!log_file.is_open()) {
        std::cerr << "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –ª–æ–≥ —Ñ–∞–π–ª –¥–ª—è –∑–∞–ø–∏—Å–∏: " << log_loc << std::endl;
        throw critical_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –ª–æ–≥ —Ñ–∞–π–ª");
    }

    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –µ–≥–æ
    auto now = std::chrono::system_clock::now();
    std::time_t t = std::chrono::system_clock::to_time_t(now);
    std::string time_str = std::ctime(&t);
    if (!time_str.empty() && time_str.back() == '\n') {
        time_str.pop_back();
    }

    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤—Ä–µ–º—è –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ª–æ–≥-—Ñ–∞–π–ª
    log_file << time_str << " / " << message << '\n';
    log_file.flush();  // —Å–±—Ä–æ—Å –±—É—Ñ–µ—Ä–∞
    // –§–∞–π–ª –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–∫—Ä–æ–µ—Ç—Å—è –ø–æ –≤—ã—Ö–æ–¥—É –∏–∑ scope

    return 0;
}

================================================================================
// –§–∞–π–ª: Logger/logger.h
================================================================================

#pragma once
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <chrono>
#include <cstring>
#include "../Error/error.h"
#include <mutex>
#include <boost/filesystem.hpp>
class logger{
    public:
    std::ofstream log;
    std::mutex mtx;
    int write_log(std::string log_loc,std::string message);
};

================================================================================
// –§–∞–π–ª: Protocol/protocol.cpp
================================================================================

#include "protocol.h"
#include <random>
#include <sstream>

std::string MessageProtocol::build(const std::string& header,
                                   const std::string& clientID,
                                   int messageID,
                                   const std::string& messageBody) {
    return header + "|clientID:" + clientID +
           "|messageID:" + std::to_string(messageID) +
           "|message:" + messageBody+"\n";
}
MessageProtocol::ParsedMessage MessageProtocol::parse(const std::string& raw) {
    std::mutex mtx;
    mtx.lock();
    ParsedMessage result;
    size_t pos = 0;
    size_t next = raw.find('|');

    // Header
    if (next == std::string::npos)
        return result; // bad format
    result.header = raw.substr(0, next);
    pos = next + 1;

    // Fields
    while ((next = raw.find('|', pos)) != std::string::npos) {
        std::string part = raw.substr(pos, next - pos);
        if (part.rfind("clientID:", 0) == 0) {
            result.clientID = part.substr(9);
        } else if (part.rfind("messageID:", 0) == 0) {
            try {
                result.messageID = std::stoi(part.substr(10));
            } catch (...) {
                result.messageID = -1;
            }
        }
        pos = next + 1;
    }

    // Last part (message)
    std::string last = raw.substr(pos);
    if (last.rfind("message:", 0) == 0) {
        result.message = last.substr(8);
        result.message.pop_back();
    }
    mtx.unlock();
    return result;
}

int MessageProtocol::generateMessageID() {
    static std::mt19937 gen(std::random_device{}());
    static std::uniform_int_distribution<> dist(1, 32);
    return dist(gen);
}


================================================================================
// –§–∞–π–ª: Protocol/protocol.h
================================================================================

#pragma once
#include <string>
#include <mutex>
class MessageProtocol {
public:
    struct ParsedMessage {
        std::string header;
        std::string clientID;
        int messageID = -1;
        std::string message;
    };

    static std::string build(const std::string& header,
                             const std::string& clientID,
                             int messageID,
                             const std::string& messageBody);

    static ParsedMessage parse(const std::string& raw);
    static int generateMessageID();
};


================================================================================
// –§–∞–π–ª: Rsa/rsa_crypto.cpp
================================================================================

#include "rsa_crypto.h"

// –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –¥–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
#define OPENSSL_API_COMPAT 0x10100000L
#include <openssl/bn.h>
#include <openssl/evp.h>

#include <stdexcept>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <fstream>
#include <random>

// --- –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (—Å–∫—Ä—ã—Ç—ã –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è) ---
namespace {

// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç BIGNUM (–∏–∑ OpenSSL) –≤ –Ω–∞—à BigInt
BigInt bignumToBigInt(const BIGNUM* bn) {
    char* hex_str = BN_bn2hex(bn);
    if (!hex_str) throw std::runtime_error("BN_bn2hex failed");

    std::string hex(hex_str);
    OPENSSL_free(hex_str);

    BigInt target;
    target.limbs.clear();
    if (hex.empty() || hex == "0") {
        return BigInt(0);
    }
    
    if (hex.size() % 16 != 0) {
        hex.insert(0, 16 - (hex.size() % 16), '0');
    }

    for (size_t i = 0; i < hex.size(); i += 16) {
        std::string part = hex.substr(i, 16);
        target.limbs.insert(target.limbs.begin(), std::stoull(part, nullptr, 16));
    }
    target.normalize();
    return target;
}

// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –Ω–∞—à BigInt –≤ BIGNUM (–∏–∑ OpenSSL)
// –í–∞–∂–Ω–æ: –≤—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥ –¥–æ–ª–∂–µ–Ω –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–∞–º—è—Ç—å —Å –ø–æ–º–æ—â—å—é BN_free()
BIGNUM* bigIntToBignum(const BigInt& bi) {
    BIGNUM* bn = nullptr;
    std::string hex = bi.toHexString();
    BN_hex2bn(&bn, hex.c_str());
    return bn;
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–æ—Å—Ç–æ—Ç—É —Å –ø–æ–º–æ—â—å—é OpenSSL
bool isPrime(const BigInt& candidate, int rounds = 64) {
    BIGNUM* bn = bigIntToBignum(candidate);
    BN_CTX* ctx = BN_CTX_new();
    int result = BN_is_prime_ex(bn, rounds, ctx, nullptr);
    BN_free(bn);
    BN_CTX_free(ctx);

    if (result < 0) throw std::runtime_error("Primality test error");
    return result == 1;
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ –≤ –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞
BigInt generatePrimeCandidate(size_t len) {
    if (len < 2) return BigInt(0);
    size_t limbCount = (len + 63) / 64;

    std::random_device rd;
    std::mt19937_64 gen(rd());
    std::uniform_int_distribution<uint64_t> dis;

    BigInt result;
    result.limbs.resize(limbCount, 0);
    for (size_t i = 0; i < limbCount; i++) {
        result.limbs[i] = dis(gen);
    }
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—à–∏–π –±–∏—Ç, —á—Ç–æ–±—ã —á–∏—Å–ª–æ –∏–º–µ–ª–æ –Ω—É–∂–Ω—É—é –¥–ª–∏–Ω—É
    result.limbs.back() |= (1ULL << ((len - 1) % 64));
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–ª–∞–¥—à–∏–π –±–∏—Ç, —á—Ç–æ–±—ã —á–∏—Å–ª–æ –±—ã–ª–æ –Ω–µ—á–µ—Ç–Ω—ã–º
    result.limbs[0] |= 1ULL;

    result.normalize();
    return result;
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞
BigInt generatePrime(size_t bitLength, int rounds) {
    while (true) {
        BigInt candidate = generatePrimeCandidate(bitLength);
        if (isPrime(candidate, rounds)) {
            return candidate;
        }
    }
}

} // –∫–æ–Ω–µ—Ü –∞–Ω–æ–Ω–∏–º–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –∏–º–µ–Ω

// --- –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–≤ BigInt ---

BigInt::BigInt() : limbs{0} {}
BigInt::BigInt(uint64_t value) {
    if (value == 0) limbs.push_back(0);
    else limbs.push_back(value);
}

void BigInt::normalize() {
    while (limbs.size() > 1 && limbs.back() == 0) {
        limbs.pop_back();
    }
}

bool BigInt::isZero() const {
    return limbs.size() == 1 && limbs[0] == 0;
}

std::string BigInt::toHexString() const {
    if (isZero()) return "0";
    std::ostringstream oss;
    oss << std::hex << std::uppercase;
    oss << limbs.back();
    for (int i = limbs.size() - 2; i >= 0; --i) {
        oss << std::setw(16) << std::setfill('0') << limbs[i];
    }
    return oss.str();
}

void BigInt::printHex(const std::string& label) const {
    if (!label.empty()) std::cout << label;
    std::cout << "0x" << this->toHexString() << std::dec << std::endl;
}


// --- –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–≤ RSAKeyPair ---

RSAKeyPair::RSAKeyPair(size_t bitLength) {
    std::cout << "üß™ Generating p..." << std::endl;
    p = generatePrime(bitLength / 2, 64);
    std::cout << "üß™ Generating q..." << std::endl;
    q = generatePrime(bitLength / 2, 64);

    BN_CTX* ctx = BN_CTX_new();
    BIGNUM* bn_p = bigIntToBignum(p);
    BIGNUM* bn_q = bigIntToBignum(q);
    
    // n = p * q
    BIGNUM* bn_n = BN_new();
    BN_mul(bn_n, bn_p, bn_q, ctx);
    n = bignumToBigInt(bn_n);

    // phi = (p-1)*(q-1)
    BIGNUM* bn_p1 = BN_dup(bn_p);
    BN_sub_word(bn_p1, 1);
    BIGNUM* bn_q1 = BN_dup(bn_q);
    BN_sub_word(bn_q1, 1);
    BIGNUM* bn_phi = BN_new();
    BN_mul(bn_phi, bn_p1, bn_q1, ctx);
    phi = bignumToBigInt(bn_phi);

    // e = 65537
    e = BigInt(65537);
    BIGNUM* bn_e = bigIntToBignum(e);

    // d = e^(-1) mod phi
    BIGNUM* bn_d = BN_mod_inverse(nullptr, bn_e, bn_phi, ctx);
    d = bignumToBigInt(bn_d);

    // –û—á–∏—Å—Ç–∫–∞
    BN_CTX_free(ctx);
    BN_free(bn_p); BN_free(bn_q); BN_free(bn_n);
    BN_free(bn_p1); BN_free(bn_q1); BN_free(bn_phi);
    BN_free(bn_e); BN_free(bn_d);
}

void RSAKeyPair::print() const {
    p.printHex("p: ");
    q.printHex("q: ");
    n.printHex("n (modulus): ");
    phi.printHex("phi: ");
    e.printHex("e (public exponent): ");
    d.printHex("d (private exponent): ");
}

// --- –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ç–¥–µ–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π ---

void saveKeyToFile(const std::string& filename, const BigInt& key) {
    std::ofstream out(filename, std::ios::binary);
    if (!out) throw std::runtime_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª –¥–ª—è –∑–∞–ø–∏—Å–∏: " + filename);
    uint64_t size = key.limbs.size();
    out.write(reinterpret_cast<const char*>(&size), sizeof(size));
    out.write(reinterpret_cast<const char*>(key.limbs.data()), size * sizeof(Limb));
}

BigInt loadKeyFromFile(const std::string& filename) {
    std::ifstream in(filename, std::ios::binary);
    if (!in) throw std::runtime_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª –¥–ª—è —á—Ç–µ–Ω–∏—è: " + filename);
    uint64_t size = 0;
    in.read(reinterpret_cast<char*>(&size), sizeof(size));
    if (!in || size == 0) throw std::runtime_error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞: " + filename);
    BigInt key;
    key.limbs.resize(size);
    in.read(reinterpret_cast<char*>(key.limbs.data()), size * sizeof(Limb));
    if (!in) throw std::runtime_error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –∫–ª—é—á–∞ –∏–∑ —Ñ–∞–π–ª–∞: " + filename);
    return key;
}

std::vector<unsigned char> sha256_hash_file(const std::string& filename) {
    std::ifstream file(filename, std::ios::binary);
    if (!file) throw std::runtime_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª: " + filename);

    EVP_MD_CTX* mdctx = EVP_MD_CTX_new();
    if (!mdctx) throw std::runtime_error("–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ EVP");
    if (1 != EVP_DigestInit_ex(mdctx, EVP_sha256(), nullptr)) {
        EVP_MD_CTX_free(mdctx);
        throw std::runtime_error("–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è");
    }

    const size_t bufSize = 4096;
    std::vector<char> buffer(bufSize);
    while (file) {
        file.read(buffer.data(), bufSize);
        if (file.gcount() > 0) {
            if (1 != EVP_DigestUpdate(mdctx, buffer.data(), file.gcount())) {
                EVP_MD_CTX_free(mdctx);
                throw std::runtime_error("–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ö–µ—à–∞");
            }
        }
    }

    std::vector<unsigned char> hash(EVP_MAX_MD_SIZE);
    unsigned int hash_len = 0;
    if (1 != EVP_DigestFinal_ex(mdctx, hash.data(), &hash_len)) {
        EVP_MD_CTX_free(mdctx);
        throw std::runtime_error("–û—à–∏–±–∫–∞ —Ñ–∏–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ —Ö–µ—à–∞");
    }
    hash.resize(hash_len);
    EVP_MD_CTX_free(mdctx);
    return hash;
}

BigInt rsa_mod_exp(const BigInt& base, const BigInt& exponent, const BigInt& modulus) {
    BN_CTX* ctx = BN_CTX_new();
    BIGNUM* bn_base = bigIntToBignum(base);
    BIGNUM* bn_exp = bigIntToBignum(exponent);
    BIGNUM* bn_mod = bigIntToBignum(modulus);
    BIGNUM* bn_res = BN_new();
    
    BN_mod_exp(bn_res, bn_base, bn_exp, bn_mod, ctx);
    
    BigInt result = bignumToBigInt(bn_res);

    BN_CTX_free(ctx);
    BN_free(bn_base); BN_free(bn_exp); BN_free(bn_mod); BN_free(bn_res);
    return result;
}

BigInt fromBytes(const std::vector<unsigned char>& bytes) {
    BIGNUM* bn = BN_bin2bn(bytes.data(), bytes.size(), nullptr);
    if (!bn) throw std::runtime_error("–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –±–∞–π—Ç–æ–≤ –≤ BigInt");
    BigInt result = bignumToBigInt(bn);
    BN_free(bn);
    return result;
}
std::vector<unsigned char> hexStringToBytes(const std::string& hex) {
    // –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é, —á—Ç–æ–±—ã –Ω–µ –∏–∑–º–µ–Ω—è—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª, –∏ —É–±–∏—Ä–∞–µ–º –ø—Ä–µ—Ñ–∏–∫—Å "0x", –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
    std::string processedHex = hex;
    if (processedHex.rfind("0x", 0) == 0 || processedHex.rfind("0X", 0) == 0) {
        processedHex = processedHex.substr(2);
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏ —á–µ—Ç–Ω–∞—è. –ö–∞–∂–¥—ã–π –±–∞–π—Ç –∫–æ–¥–∏—Ä—É–µ—Ç—Å—è –¥–≤—É–º—è HEX-—Å–∏–º–≤–æ–ª–∞–º–∏.
    if (processedHex.length() % 2 != 0) {
        throw std::invalid_argument("–®–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å —á–µ—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–º–≤–æ–ª–æ–≤.");
    }

    std::vector<unsigned char> bytes;
    // –†–µ–∑–µ—Ä–≤–∏—Ä—É–µ–º –ø–∞–º—è—Ç—å –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    bytes.reserve(processedHex.length() / 2);

    for (size_t i = 0; i < processedHex.length(); i += 2) {
        // –ë–µ—Ä–µ–º –¥–≤–∞ —Å–∏–º–≤–æ–ª–∞ (–æ–¥–∏–Ω –±–∞–π—Ç)
        std::string byteString = processedHex.substr(i, 2);
        try {
            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –¥–≤–∞ HEX-—Å–∏–º–≤–æ–ª–∞ –≤ —á–∏—Å–ª–æ –∏ –¥–æ–±–∞–≤–ª—è–µ–º –≤ –≤–µ–∫—Ç–æ—Ä
            unsigned char byte = static_cast<unsigned char>(std::stoul(byteString, nullptr, 16));
            bytes.push_back(byte);
        } catch (const std::exception& e) {
            throw std::invalid_argument("–°—Ç—Ä–æ–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã: '" + byteString + "'");
        }
    }

    return bytes;
}
BigInt BigInt::fromHexString(const std::string& hexString) {
    BIGNUM* bn = nullptr;
    std::string processedHex = hexString;
    // –£–¥–∞–ª—è–µ–º –ø—Ä–µ—Ñ–∏–∫—Å "0x" –∏–ª–∏ "0X", –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
    if (processedHex.rfind("0x", 0) == 0 || processedHex.rfind("0X", 0) == 0) {
        processedHex = processedHex.substr(2);
    }
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—É—é —Å—Ç—Ä–æ–∫—É –≤ OpenSSL BIGNUM
    // BN_hex2bn –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 0 –ø—Ä–∏ –æ—à–∏–±–∫–µ, 1 –ø—Ä–∏ —É—Å–ø–µ—Ö–µ.
    if (!BN_hex2bn(&bn, processedHex.c_str())) {
        if (bn) BN_free(bn); // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º, –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ –±—ã–ª–æ –≤—ã–¥–µ–ª–µ–Ω–æ –¥–æ –æ—à–∏–±–∫–∏
        throw std::runtime_error("Failed to convert hexadecimal string to BIGNUM: " + processedHex);
    }
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º OpenSSL BIGNUM –≤ –Ω–∞—à BigInt
    BigInt result = bignumToBigInt(bn);
    
    // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–∞–º—è—Ç—å, –≤—ã–¥–µ–ª–µ–Ω–Ω—É—é OpenSSL –¥–ª—è BIGNUM
    BN_free(bn);
    
    return result;
}

================================================================================
// –§–∞–π–ª: Rsa/rsa_crypto.h
================================================================================

#ifndef RSA_CRYPTO_H
#define RSA_CRYPTO_H

#include <string>
#include <vector>
#include <cstdint>

// –¢–∏–ø –¥–ª—è "–∫–æ–Ω–µ—á–Ω–æ—Å—Ç–µ–π" –±–æ–ª—å—à–æ–≥–æ —á–∏—Å–ª–∞
using Limb = uint64_t;

/**
 * @brief –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ –±–æ–ª—å—à–∏—Ö —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª.
 */
struct BigInt
{
    std::vector<Limb> limbs; // –•—Ä–∞–Ω—è—Ç—Å—è –≤ little-endian (–º–ª–∞–¥—à–∞—è —á–∞—Å—Ç—å –≤ –Ω–∞—á–∞–ª–µ)

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    BigInt();
    BigInt(uint64_t value);

    // –ú–µ—Ç–æ–¥—ã
    void normalize(); // –£–¥–∞–ª—è–µ—Ç –≤–µ–¥—É—â–∏–µ –Ω—É–ª–∏
    bool isZero() const;
    void printHex(const std::string &label = "") const;
    std::string toHexString() const;
    static BigInt fromHexString(const std::string& hexString);
};

/**
 * @brief –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–∞—Ä—ã –∫–ª—é—á–µ–π RSA.
 */
struct RSAKeyPair
{
    BigInt p, q, n, phi, e, d;

    /**
     * @brief –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –Ω–æ–≤—É—é –ø–∞—Ä—É –∫–ª—é—á–µ–π RSA –∑–∞–¥–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã.
     * @param bitLength –î–ª–∏–Ω–∞ –∫–ª—é—á–∞ –≤ –±–∏—Ç–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, 2048).
     */
    RSAKeyPair(size_t bitLength);

    /**
     * @brief –í—ã–≤–æ–¥–∏—Ç –≤—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∫–ª—é—á–µ–π –≤ –∫–æ–Ω—Å–æ–ª—å.
     */
    void print() const;
};

// --- –û—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –º–æ–¥—É–ª—è ---

/**
 * @brief –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–ª—é—á (BigInt) –≤ –±–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª.
 * @param filename –ò–º—è —Ñ–∞–π–ª–∞.
 * @param key –ö–ª—é—á –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è.
 */
void saveKeyToFile(const std::string &filename, const BigInt &key);

/**
 * @brief –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∫–ª—é—á (BigInt) –∏–∑ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ —Ñ–∞–π–ª–∞.
 * @param filename –ò–º—è —Ñ–∞–π–ª–∞.
 * @return –ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π –∫–ª—é—á —Ç–∏–ø–∞ BigInt.
 */
BigInt loadKeyFromFile(const std::string &filename);

/**
 * @brief –í—ã—á–∏—Å–ª—è–µ—Ç —Ö–µ—à SHA-256 –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞.
 * @param filename –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É.
 * @return –í–µ–∫—Ç–æ—Ä –±–∞–π—Ç, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∏–π —Ö–µ—à.
 */
std::vector<unsigned char> sha256_hash_file(const std::string &filename);

/**
 * @brief –í—ã–ø–æ–ª–Ω—è–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏—é –º–æ–¥—É–ª—å–Ω–æ–≥–æ –≤–æ–∑–≤–µ–¥–µ–Ω–∏—è –≤ —Å—Ç–µ–ø–µ–Ω—å (–æ—Å–Ω–æ–≤–∞^—ç–∫—Å–ø–æ–Ω–µ–Ω—Ç–∞ % –º–æ–¥—É–ª—å).
 * –≠—Ç–æ –æ—Å–Ω–æ–≤–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –∏ –ø–æ–¥–ø–∏—Å–∏ –≤ RSA.
 * @param base –û—Å–Ω–æ–≤–∞–Ω–∏–µ.
 * @param exponent –≠–∫—Å–ø–æ–Ω–µ–Ω—Ç–∞ (—Å—Ç–µ–ø–µ–Ω—å).
 * @param modulus –ú–æ–¥—É–ª—å.
 * @return –†–µ–∑—É–ª—å—Ç–∞—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏ (BigInt).
 */
BigInt rsa_mod_exp(const BigInt &base, const BigInt &exponent, const BigInt &modulus);

/**
 * @brief –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –≤–µ–∫—Ç–æ—Ä –±–∞–π—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ö–µ—à) –≤ BigInt.
 * @param bytes –í—Ö–æ–¥–Ω–æ–π –≤–µ–∫—Ç–æ—Ä –±–∞–π—Ç.
 * @return –û–±—ä–µ–∫—Ç BigInt.
 */
BigInt fromBytes(const std::vector<unsigned char> &bytes);
std::vector<unsigned char> hexStringToBytes(const std::string &hexString);
#endif // RSA_CRYPTO_H

================================================================================
// –§–∞–π–ª: App_logic/AppLogic.cpp
================================================================================

// –§–∞–π–ª: App_logic/AppLogic.cpp
#include "AppLogic.h"

// –ü—Ä—è–º–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç —É—Ç–∏–ª–∏—Ç –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –∏ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏
#include "../Protocol_utils/protocol_utils.h"
#include "../Crypto_utils/crypto_utils.h"

// –°–∏—Å—Ç–µ–º–Ω—ã–µ –∏–Ω–∫–ª—é–¥—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Å–æ–∫–µ—Ç–∞–º–∏
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdexcept>
#include <cerrno>  // –¥–ª—è errno
#include <cstring> // –¥–ª—è strerror

// --- –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∏ –î–µ—Å—Ç—Ä—É–∫—Ç–æ—Ä ---

AppLogic::AppLogic(
    const std::string& ip, uint16_t port, const std::string& username, 
    const std::string& password, std::shared_ptr<logger> logger_instance,
    const std::string& log_path
) :
    m_server_ip(ip),
    m_server_port(port),
    m_user_name(username),
    m_user_password(password),
    m_logger(logger_instance),
    m_log_path(log_path)
{
    if (!m_logger) {
        throw std::invalid_argument("Logger instance in AppLogic cannot be null.");
    }
}

AppLogic::~AppLogic() {
    disconnect();
}

// --- –û–°–ù–û–í–ù–´–ï –°–¶–ï–ù–ê–†–ò–ò ---

void AppLogic::run_login_flow() {
    m_logger->write_log(m_log_path, "[AppLogic] –ó–∞–ø—É—Å–∫ –∫–ª–∏–µ–Ω—Ç–∞ –¥–ª—è '" + m_user_name + "' –≤ —Ä–µ–∂–∏–º–µ –ê–£–¢–ï–ù–¢–ò–§–ò–ö–ê–¶–ò–ò.");
    
    if (!connect_to_server()) {
        m_console.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É.");
        return;
    }
    
    if (perform_authentication()) {
        main_loop();
    } else {
        m_console.show_error("–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å. –û—Ç–∫–ª—é—á–µ–Ω–∏–µ.");
    }

    disconnect();
    m_console.show_message("–†–∞–±–æ—Ç–∞ –∫–ª–∏–µ–Ω—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.");
    m_logger->write_log(m_log_path, "[AppLogic] –ö–ª–∏–µ–Ω—Ç —à—Ç–∞—Ç–Ω–æ –∑–∞–≤–µ—Ä—à–∏–ª —Ä–∞–±–æ—Ç—É.");
}

void AppLogic::run_registration_flow() {
    m_logger->write_log(m_log_path, "[AppLogic] –ó–∞–ø—É—Å–∫ –∫–ª–∏–µ–Ω—Ç–∞ –¥–ª—è '" + m_user_name + "' –≤ —Ä–µ–∂–∏–º–µ –†–ï–ì–ò–°–¢–†–ê–¶–ò–ò.");

    if (!connect_to_server()) {
        m_console.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É.");
        return;
    }
    
    m_logger->write_log(m_log_path, "[AppLogic] –ù–∞—á–∞–ª–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.");
    if (!send_message({ "REGISTER", m_user_name, -1, "" })) {
        disconnect(); return;
    }
    
    if (!send_message({ "PASSWORD", m_user_name, -1, m_user_password })) {
        disconnect(); return;
    }
    
    auto reg_result = receive_message();
    if (reg_result && reg_result->header == "REG_OK") {
        m_logger->write_log(m_log_path, "[AppLogic] –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞.");
        m_console.show_message("–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è '" + m_user_name + "' –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!");
    } else {
        std::string error_details = reg_result ? reg_result->message : "—Å–µ—Ä–≤–µ—Ä –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç";
        m_logger->write_log(m_log_path, "[AppLogic] –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–æ–≤–∞–ª–µ–Ω–∞: " + error_details);
        m_console.show_error("–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å: " + error_details);
    }
    
    disconnect();
}


// --- –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –º–µ—Ç–æ–¥—ã ---

bool AppLogic::is_connected() const {
    return m_socket != -1;
}

bool AppLogic::connect_to_server() {
    m_logger->write_log(m_log_path, "[AppLogic] –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ " + m_server_ip + ":" + std::to_string(m_server_port));
    
    m_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (m_socket < 0) { 
        m_logger->write_log(m_log_path, "[AppLogic] –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–æ–∫–µ—Ç–∞: " + std::string(strerror(errno)));
        return false;
    }

    sockaddr_in server_addr{};
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(m_server_port);
    if (inet_pton(AF_INET, m_server_ip.c_str(), &server_addr.sin_addr) <= 0) {
        m_logger->write_log(m_log_path, "[AppLogic] –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π IP –∞–¥—Ä–µ—Å " + m_server_ip);
        disconnect();
        return false;
    }
    
    if (::connect(m_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        m_logger->write_log(m_log_path, "[AppLogic] –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É: " + std::string(strerror(errno)));
        disconnect();
        return false;
    }
    
    auto welcome_msg = receive_message();
    if (!welcome_msg) {
        m_logger->write_log(m_log_path, "[AppLogic] –°–µ—Ä–≤–µ—Ä –Ω–µ –ø—Ä–∏—Å–ª–∞–ª –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.");
        return false;
    }
    
    if (welcome_msg->header == "CONN_REJECT") {
         m_logger->write_log(m_log_path, "[AppLogic] –û—Ç–∫–∞–∑ –≤ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏: " + welcome_msg->message);
         disconnect();
         return false;
    }
    
    if (welcome_msg->header != "CONN_ACCEPT") {
        m_logger->write_log(m_log_path, "[AppLogic] –û—à–∏–±–∫–∞: –ø–æ–ª—É—á–µ–Ω–æ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ: " + welcome_msg->header);
        disconnect();
        return false;
    }
    
    m_logger->write_log(m_log_path, "[AppLogic] –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Å–µ—Ä–≤–µ—Ä–æ–º —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ.");
    return true;
}

void AppLogic::disconnect() {
    if (is_connected()) {
        m_logger->write_log(m_log_path, "[AppLogic] –ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–∫–µ—Ç–∞.");
        ::close(m_socket);
        m_socket = -1;
    }
}

bool AppLogic::send_message(const MessageProtocol::ParsedMessage& msg) {
    if (!is_connected()) {
        m_logger->write_log(m_log_path, "[AppLogic] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è.");
        return false;
    }
    if (ProtocolUtils::send_formatted_message(m_socket, msg.header, msg.clientID, msg.messageID, msg.message) != 0) {
        m_logger->write_log(m_log_path, "[AppLogic] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è, —Ä–∞–∑—Ä—ã–≤ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è.");
        disconnect();
        return false;
    }
    return true;
}

std::optional<MessageProtocol::ParsedMessage> AppLogic::receive_message() {
    if (!is_connected()) return std::nullopt;
    auto msg = ProtocolUtils::receive_and_parse_message(m_socket);
    if (!msg) {
        m_logger->write_log(m_log_path, "[AppLogic] –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –±—ã–ª–æ —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ –≤–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è.");
        disconnect();
    }
    return msg;
}

bool AppLogic::perform_authentication() {
    m_logger->write_log(m_log_path, "[AppLogic] –ù–∞—á–∞–ª–æ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏.");
    
    if (!send_message({ "LOGIN", m_user_name, -1, "" })) return false;

    auto challenge_msg = receive_message();
    if (!challenge_msg || challenge_msg->header != "CHALLENGE") {
        m_logger->write_log(m_log_path, "[AppLogic] –û—à–∏–±–∫–∞: –Ω–µ –ø–æ–ª—É—á–µ–Ω –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π challenge –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞.");
        return false;
    }
    
    const std::string& nonce = challenge_msg->message;
    std::string pass_hash = CryptoUtils::generate_hash(m_user_password);
    std::string response_hash = CryptoUtils::generate_hash(pass_hash + nonce);

    if (!send_message({ "CHALLENGE_RESPONSE", m_user_name, -1, response_hash })) return false;
    
    auto auth_result = receive_message();
    if (auth_result && auth_result->header == "AUTH_OK") {
        m_logger->write_log(m_log_path, "[AppLogic] –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞.");
        m_console.show_message("–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!");
        return true;
    } else {
        std::string error_details = auth_result ? auth_result->message : "—Å–µ—Ä–≤–µ—Ä –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç";
        m_logger->write_log(m_log_path, "[AppLogic] –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø—Ä–æ–≤–∞–ª–µ–Ω–∞: " + error_details);
        return false;
    }
}

void AppLogic::main_loop() {
    while (is_connected()) {
        UserMenuChoice choice = m_console.get_user_menu_choice();
        
        if (choice == UserMenuChoice::EXIT) {
            send_message({ "LOGOUT", m_user_name, -1, "" });
            break; 
        }

        switch (choice) {
            case UserMenuChoice::REQUEST_SIGNATURE: handle_signing_request(); break;
            case UserMenuChoice::VERIFY_LOCALLY: handle_verification_request(); break;
            case UserMenuChoice::UNKNOWN:
            default:
                m_console.show_error("–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.");
                break;
        }
    }
}

void AppLogic::handle_signing_request() {
    m_logger->write_log(m_log_path, "[AppLogic] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–ø—Ä–æ—Å–∏–ª –ø–æ–¥–ø–∏—Å—å —Ñ–∞–π–ª–∞.");
    
    std::string file_path = m_console.ask_filepath("–í–≤–µ–¥–∏—Ç–µ –ø–æ–ª–Ω—ã–π –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –¥–ª—è –ø–æ–¥–ø–∏—Å–∏: ");
    if (file_path.empty()) return;

    std::string hex_hash;
    try {
        hex_hash = m_signature_service.hash_file(file_path);
    } catch (const std::exception& e) {
        m_console.show_error(e.what());
        m_logger->write_log(m_log_path, "[AppLogic] –û—à–∏–±–∫–∞ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è: " + std::string(e.what()));
        return;
    }
    
    // ================== –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï ==================
    // –®–ê–ì –ê: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É, –ß–¢–û –º—ã —Ö–æ—Ç–∏–º —Å–¥–µ–ª–∞—Ç—å. –¢–µ–ª–æ —Å–æ–æ–±—â–µ–Ω–∏—è –ø—É—Å—Ç–æ–µ.
    m_logger->write_log(m_log_path, "[AppLogic] –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–∞–Ω–¥—ã SIGN_HASH –Ω–∞ —Å–µ—Ä–≤–µ—Ä.");
    if (!send_message({ "SIGN_HASH", m_user_name, -1, "" })) {
        m_console.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–º–∞–Ω–¥—É –Ω–∞ —Å–µ—Ä–≤–µ—Ä.");
        return;
    }

    // –®–ê–ì –ë: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –î–ê–ù–ù–´–ï –¥–ª—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã. –ó–∞–≥–æ–ª–æ–≤–æ–∫ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –ª—é–±—ã–º
    // –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—ã–º, –Ω–∞–ø—Ä–∏–º–µ—Ä HASH_DATA, –∏–ª–∏ –¥–∞–∂–µ –æ—Å—Ç–∞–≤–∏—Ç—å –ø—É—Å—Ç—ã–º, —Ç.–∫. —Å–µ—Ä–≤–µ—Ä –µ–≥–æ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç.
    m_logger->write_log(m_log_path, "[AppLogic] –û—Ç–ø—Ä–∞–≤–∫–∞ —Ö–µ—à–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä: " + hex_hash);
    if (!send_message({ "HASH_DATA", m_user_name, -1, hex_hash })) {
        m_console.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ö–µ—à –Ω–∞ —Å–µ—Ä–≤–µ—Ä.");
        return;
    }
    // =================================================

    // –¢–µ–ø–µ—Ä—å –ø–æ–ª—É—á–∞–µ–º –æ—Ç–≤–µ—Ç (–ø–æ–¥–ø–∏—Å—å)
    auto response = receive_message();
    if (response && response->header == "SIGN_SUCCESS") {
        // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–¥–ø–∏—Å–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ...
        const std::string& signature_hex = response->message;
        m_console.display_signature(signature_hex);
        try {
            m_signature_service.save_signature(file_path, signature_hex);
            m_console.show_message("–ü–æ–¥–ø–∏—Å—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ —Ñ–∞–π–ª: " + file_path + ".sig");
        } catch (const std::exception& e) {
            m_console.show_error(e.what());
        }
    } else {
        std::string err = response ? response->message : "—Å–µ—Ä–≤–µ—Ä —Ä–∞–∑–æ—Ä–≤–∞–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ";
        m_console.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–æ–¥–ø–∏—Å—å: " + err);
    }
}

void AppLogic::handle_verification_request() {
    m_logger->write_log(m_log_path, "[AppLogic] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–ø—Ä–æ—Å–∏–ª –ø—Ä–æ–≤–µ—Ä–∫—É –ø–æ–¥–ø–∏—Å–∏.");
    
    BigInt n, e;
    if (!request_public_key(n, e)) {
        m_console.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞.");
        return;
    }
    m_console.show_message("–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —É—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω.");
    
    std::string original_path = m_console.ask_filepath("–í–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –∫ –û–†–ò–ì–ò–ù–ê–õ–¨–ù–û–ú–£ —Ñ–∞–π–ª—É: ");
    if (original_path.empty()) return;

    std::string signature_path = m_console.ask_filepath("–í–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –ü–û–î–ü–ò–°–ò (*.sig): ");
    if (signature_path.empty()) return;
    
    try {
        bool is_valid = m_signature_service.verify_signature(original_path, signature_path, n, e);
        m_console.display_verification_result(is_valid);
        m_logger->write_log(
        m_log_path, 
        std::string("[AppLogic] –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –†–µ–∑—É–ª—å—Ç–∞—Ç: ") + (is_valid ? "–£–°–ü–ï–•" : "–ü–†–û–í–ê–õ")
    );
    } catch (const std::exception& e) {
        m_console.show_error(e.what());
        m_logger->write_log(m_log_path, "[AppLogic] –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏: " + std::string(e.what()));
    }
}

bool AppLogic::request_public_key(BigInt& out_n, BigInt& out_e) {
    m_logger->write_log(m_log_path, "[AppLogic] –ó–∞–ø—Ä–æ—Å –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–ª—é—á–∞ —É —Å–µ—Ä–≤–µ—Ä–∞.");
    
    if (!send_message({ "GET_PUB_KEY", m_user_name, -1, "" })) return false;

    auto n_response = receive_message();
    if (!n_response || n_response->header != "PUB_KEY_N") {
        m_logger->write_log(m_log_path, "[AppLogic] –û—à–∏–±–∫–∞: –Ω–µ –ø–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ N –∫–ª—é—á–∞.");
        return false;
    }
    auto e_response = receive_message();
    if (!e_response || e_response->header != "PUB_KEY_E") {
         m_logger->write_log(m_log_path, "[AppLogic] –û—à–∏–±–∫–∞: –Ω–µ –ø–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ E –∫–ª—é—á–∞.");
        return false;
    }
    
    try {
        out_n = BigInt::fromHexString(n_response->message);
        out_e = BigInt::fromHexString(e_response->message);
        m_logger->write_log(m_log_path, "[AppLogic] –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —É—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω –∏ —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω.");
        return true;
    } catch (const std::exception& e) {
        m_logger->write_log(m_log_path, "[AppLogic] –û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –∫–ª—é—á–∞ –∏–∑ HEX: " + std::string(e.what()));
        return false;
    }
}

================================================================================
// –§–∞–π–ª: App_logic/AppLogic.h
================================================================================

// –§–∞–π–ª: App_logic/AppLogic.h
#pragma once

#include <string>
#include <memory>
#include <optional>
#include <cstdint>

// –í–∫–ª—é—á–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –≤—Å–µ—Ö –º–æ–¥—É–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–º–∏ –±—É–¥–µ–º —É–ø—Ä–∞–≤–ª—è—Ç—å
#include "../Service/SignatureService.h"
#include "../UI/InteractiveConsole.h"
#include "../Logger/logger.h"
#include "../Rsa/rsa_crypto.h"
#include "../Protocol/protocol.h" // –î–ª—è ParsedMessage

class AppLogic {
public:
    AppLogic(
        const std::string& ip,
        uint16_t port,
        const std::string& username,
        const std::string& password,
        std::shared_ptr<logger> logger_instance,
        const std::string& log_path
    );
    
    ~AppLogic();

    // –ó–∞–ø—Ä–µ—â–∞–µ–º –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ, —Ç.–∫. —É–ø—Ä–∞–≤–ª—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–º —Ä–µ—Å—É—Ä—Å–æ–º (—Å–æ–∫–µ—Ç–æ–º)
    AppLogic(const AppLogic&) = delete;
    AppLogic& operator=(const AppLogic&) = delete;

    // --- –û—Å–Ω–æ–≤–Ω—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –∑–∞–ø—É—Å–∫–∞ ---
    void run_login_flow();
    void run_registration_flow();

private:
    // --- –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ —Å–µ—Ç–µ–≤—ã–µ –º–µ—Ç–æ–¥—ã ---
    bool connect_to_server();
    void disconnect();
    bool send_message(const MessageProtocol::ParsedMessage& msg);
    std::optional<MessageProtocol::ParsedMessage> receive_message();
    bool is_connected() const;

    // --- –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –º–µ—Ç–æ–¥—ã –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∏ ---
    bool perform_authentication();
    void main_loop();
    void handle_signing_request();
    void handle_verification_request();
    bool request_public_key(BigInt& out_n, BigInt& out_e);
    
    // --- –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ ---
    int m_socket = -1; // –¢–µ–ø–µ—Ä—å —Å–æ–∫–µ—Ç –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç AppLogic

    // –î–∞–Ω–Ω—ã–µ —Å–µ—Å—Å–∏–∏
    std::string m_server_ip;
    uint16_t m_server_port;
    std::string m_user_name;
    std::string m_user_password;
    std::string m_log_path;

    // –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã-–∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–∏
    SignatureService m_signature_service;
    InteractiveConsole m_console;
    std::shared_ptr<logger> m_logger;
};

